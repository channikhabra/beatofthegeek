<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ubuntu | Beat of The Geek]]></title>
  <link href="http://\.github.io/\/github/blog/categories/ubuntu/atom.xml" rel="self"/>
  <link href="http://\.github.io/\/github/"/>
  <updated>2015-11-04T08:05:54+05:30</updated>
  <id>http://\.github.io/\/github/</id>
  <author>
    <name><![CDATA[Charanjit Singh]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[/etc/passwd illustrated]]></title>
    <link href="http://\.github.io/\/github/2013/12/etcpasswd-illustrated.html"/>
    <updated>2013-12-22T00:00:00+05:30</updated>
    <id>http://\.github.io/\/github/2013/12/etcpasswd-illustrated</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on"><h1 id="etcpasswd_illustrated"></h1><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-dtO8EFBJ8AI/Uldeu-QcfvI/AAAAAAAAAis/y8i9xXh03h0/s1600/passwd.png" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" height="200" src="http://1.bp.blogspot.com/-dtO8EFBJ8AI/Uldeu-QcfvI/AAAAAAAAAis/y8i9xXh03h0/s200/passwd.png" width="200" /></a></div><i>etc/passwd file is is located, well, in /etc directory. /etc</i> stores most of the system level configurations for a typical  UNIX(-like) system. There are more than one ways to do something on a  UNIX(-like) system. We’ll discuss about some commands no the way which  can be used to do stuff we gonna do by tinkering with /etc/passwd in  this post. So let’s talk less and discuss something about the  /etc/passwd without loosing time.<br /><h3 id="why_do_etcpasswd_exist" style="text-align: left;">&nbsp;</h3><h3 id="why_do_etcpasswd_exist" style="text-align: left;">Why do /etc/passwd exist?</h3><br />So the first question that would come in a mortal mind is ‘what  for?’. Why do /etc/passwd even exist? It saves the information about all  the users on a system. Original use of this file was to store almost  all the data related to a user, including passwords. May be that’s the  reason behind its name. But don’t worry, passwords are no longer stored  as plain text in this file. More on this in later sections.<br /><h3 id="structure_of_etcpasswd" style="text-align: left;">&nbsp;<!-- more --></h3><h3 id="structure_of_etcpasswd" style="text-align: left;">Structure of /etc/passwd</h3><br />If you are on a GNU/Linux or similar system right now, you can take a  look at it. User info is stored in this file in single lines, new lines  for different users, with colons(’:’) as the separating character.  Quick, run this command:<br /><blockquote>head -n 1 /etc/passwd</blockquote>This will get you the first line of the file. If you do ‘cat  /etc/passwd’, you will see there are many lines. More than the users you  have made. Linux (and other Unix like systems) make users for running  some special processes which need some certain set of special  permissions. If you want to look which is the line for you (the  presently logged in user that is), run this<br /><blockquote>cat /etc/passwd | grep username</blockquote>On my system, it look like this:<br /><blockquote><blockquote>channi:x:1000:100:Charanjit Singh,Beat of the Geek:/home/channi:/bin/zsh</blockquote></blockquote>Different fields of the file are separated by colons(’:’). If you count, there are 7 columns in total. Lets discuss them all.<br /><h3 id="first_column_of_etcpasswd" style="text-align: left;">&nbsp;</h3><h3 id="first_column_of_etcpasswd" style="text-align: left;">First column of /etc/passwd</h3><br />It’s your login name. The name you enter when you login to the system  (or choose from the GUI). Yes, your login name will change if you  change the /etc/passwd file here. There are many ways of changing things  in GNU/Linux, and most of the times they are different commands which  change the underlying configuration files like this one.<br /><h2 id="alternative_command_for_changing_the_login_name" style="text-align: left;">&nbsp;</h2><h2 id="alternative_command_for_changing_the_login_name" style="text-align: left;">Alternative command for changing the login name</h2><br /><b>usermod -l NEWNAME</b> oldname<br /><br />Some system (including Ubuntu) offer another command for making changes to user info. To your surprise, it’s called <b>moduser</b> The difference b/w usermod and moduser is that of sophistication. Which  one is more sophisticated is arguable though. usermod uses flags to set  different information, and moduser provide an interface which ask you  for the information in a menu like manner. Try them yourself.<br /><h3 id="second_column_of_etcpasswd" style="text-align: left;">&nbsp;</h3><h3 id="second_column_of_etcpasswd" style="text-align: left;">Second column of /etc/passwd</h3><br />That’s your login password. Surprised? Your actual password is not  stored in this file actually. It’s not secure to store it in plain text  here, or even in ciphered form. Many programs need access to this file  for read purposes. Did you notice you didn’t need to enter root password  for reading /etc/passwd? So where is the password stored in Linux? Your  real password is ciphered with a secure one-way encryption algorithm  and is stored in a shadow file (/etc/shadow). Try to do ‘cat’ on it. Yes  you can’t. And that is justifiable. If you cat it with root password,  you will see login names and a jumbled word in front of them. That’s the  ciphered password. We’ll probably discuss them some other day. So since  the password is not stored here, we can’t do anything about it by  editing /etc/passwd, right? Not really. There is one thing we can do. If  you change the ‘x’ in there with an asterisk ’*’, the account gets  disabled and can’t be used. Actually if you change that ‘x’ (or if your  system has some other value there), it simply won’t work. The user is  greeted with charming ‘Authentication Failure’ messages.<br /><h3 id="third_column_of_etcpasswd" style="text-align: left;">&nbsp;</h3><h3 id="third_column_of_etcpasswd" style="text-align: left;">Third column of /etc/passwd</h3><br />In the third column comes user’s user id (UID you call it). A UID is a  unique id assigned by the system to each user on the system. Usernames  are only for humans, system itself identifies a user by its UID. You can  change this number (obviously) but it’s not recommended. There are  certain complications which may arise when you change the UID of a user  (remember file permissions? cron tabs?). If you want to change the uid,  better do it with <b>usermod -u</b>.<br /><h3 id="fourth_column_of_etcpasswd" style="text-align: left;">&nbsp;</h3><h3 id="fourth_column_of_etcpasswd" style="text-align: left;">Fourth column of /etc/passwd</h3><br />Similar to the uid, that’s the users gid (Group ID). It’s the id of  primary group of the user. On most systems it is set same as the uid  (not on mine though). You can change it with <b>usermod -g</b> command.<br /><blockquote><b>usermod -g</b></blockquote>If you want to know different id’s related to a user, feel free to use <b>id</b> command. It will tell you many different ids. Just type<br /><blockquote><b>id</b></blockquote>You can see different groups the user is member of with <b>groups</b> command.<br /><blockquote><b>groups</b></blockquote><h3 id="fifth_column" style="text-align: left;">&nbsp;</h3><h3 id="fifth_column" style="text-align: left;">Fifth column</h3><br />This field contains comments about a user. It’s called the <a href="http://en.m.wikipedia.org/wiki/Gecos_field">gecos field</a> and contains a comma separated list of the extra information about a user like full name, address etc. Apart from <b>usermod -c</b>, you can use <b>chfn</b> to change this field. <b>chfn</b> <i>chfn</i> is abbreviation for ‘change finger info’. Most of the information related to a user can be accessed with <b>finger</b> command. In other words, someone with access the system can finger you to get information (pun intended). Check it out: <b>&nbsp;</b><br /><br /><b>finger USERNAME</b><br /><h3 id="sixth_column" style="text-align: left;">&nbsp;</h3><h3 id="sixth_column" style="text-align: left;">Sixth column</h3><br />That’s the path to user’s home directory. It can be changed here or with <b>usermod -d</b> command. Although there are other ways of changing it (including  editing /etc/passwd file), but it is recommended not to do it that way.  We’ll probably discuss the complications some other day.<br /><blockquote><b>usermod -d /home/new-home USERNAME</b></blockquote><h3 id="seventh_column" style="text-align: left;">&nbsp;</h3><h3 id="seventh_column" style="text-align: left;">Seventh column</h3><br />That’s the final column of the /etc/passwd file. It contains the  shell for the users. Actually it’s the path to a program which is  executed everytime a user logs in to the system. For the normal users it  is a shell. It can be safely changed here or with <b>usermod -s</b>. Another quick command for changing default shell for a user is <b>chsh</b>.<br /><blockquote><b>chsh</b></blockquote></div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to install software in Linux without using any package manager]]></title>
    <link href="http://\.github.io/\/github/2013/05/how-to-install-software-in-linux.html"/>
    <updated>2013-05-08T00:00:00+05:30</updated>
    <id>http://\.github.io/\/github/2013/05/how-to-install-software-in-linux</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><a href="http://2.bp.blogspot.com/-LwNIMQDugwc/UYniJZ7TV5I/AAAAAAAAAgk/pvSbAPhtn8k/s1600/images.jpg" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" src="http://2.bp.blogspot.com/-LwNIMQDugwc/UYniJZ7TV5I/AAAAAAAAAgk/pvSbAPhtn8k/s1600/images.jpg" height="258" width="320" /></a>Package managers are awesome. As awesome as automatic software installation get you. Would it be apt, yum or pacman, they are all awesome for their systems. But sometimes we need to install binaries. Your package manager knows how to install a .deb or .rpm, but what about the stuff in that ./bin folder of the tar.bz2 bundle of latest version of your favorite software you just downloaded? No, it can't be handled with the package manager.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <!-- more --><br /><h3 style="text-align: left;"></h3><h3 style="text-align: left;">Why installing binaries?</h3>Why would I need to use binaries you say!? Yea you are right, packaged software from the repositories of your trustworthy GNU/Linux distro is well tested and all, but sometime it's not enough. Here are some reasons you might consider good enough for occasionally using binaries.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /><blockquote class="tr_bq"><ul style="text-align: left;"><li><b>Software in repositories are not always up-to-date</b> (you know better Ubuntu users)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </li></ul></blockquote><blockquote class="tr_bq"><ul style="text-align: left;"><li><b>Some super awesome software is not available form repositories&nbsp;&nbsp;</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </li></ul></blockquote><blockquote class="tr_bq"><ul style="text-align: left;"><li><b>You have compiled something yourself and you wanna use it as an installed software now&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b></li></ul></blockquote><blockquote class="tr_bq"><ul style="text-align: left;"><li><b>You have built a software/script yourself and want to use it directly from command line&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b></li></ul></blockquote>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; etc etc. There are many.<br /><h3 style="text-align: left;">How to execute binaries?</h3>I know you all know this, but let's not leave the new guy behind. In Linux, when you have got a binary file (you can download latest firefox package for linux for an example), you need to first make it executable.<br />Try the following command for that.<br /><blockquote class="tr_bq"><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chmod +x /path/to/binary/file</i></blockquote>This should be enough. You can now execute the binary by simply double clicking it, or from the terminal with just write it's path in terminal and pressing enter.<br /><blockquote class="tr_bq"><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ./firefox&nbsp;</i><br /><enter></enter></blockquote><h4 style="text-align: left;"><enter>So what's the fuss?</enter></h4><enter>Yea, it's that simple to execute a binary. But wouldn't it be better if we would not need to write the whole path to the file everytime we need to execute it? Wouldn't it be sweet if we could just use it like any other command from the terminal, like 'cd'? Yes I know it'll be awesome.&nbsp;</enter><br /><h3 style="text-align: left;"><enter>How to directly install binaries in Linux</enter></h3><enter>There are many ways to do this. We'll touch here some of them (enough of them that you'll be able to install binaries on any Linux distro, would it be Ubuntu, Fedora, Arch or whatever). Let's precede with the simplest of them.&nbsp;</enter><br /><h3 style="text-align: left;"><enter>Creating a symlink in the </enter><enter>$PATH</enter></h3><h3><enter></enter></h3><enter>We need some explanation here (I suppose). What is a symlink? What is $PATH?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />Well, symlink is thing you call 'shortcut' in windows. It's a symbolic link (shortcut) to some file or folder.&nbsp;</enter><br /><enter>And $PATH? It's a list of all the directories (folders) in which our Linux system search for commands. Any executable file placed in any of the folders included in $PATH is treated as a command and can be directly executed from terminal. You can see what's in $PATH on your system with this:&nbsp; </enter><br /><blockquote class="tr_bq"><enter><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo $PATH</i></enter><br /><enter></enter></blockquote><enter>So what we are gonna do is create a symlink of our binary file and place it in one of the folders in $PATH. That should be enough to make it a command in itself.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </enter><br /><blockquote class="tr_bq"><enter><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ln -s /path/to/file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i></enter></blockquote>&nbsp;Above is the command to create a symlink. It will create the symlink and place it in the $HOME (that's your home folder). You can then move the link from there and place it in one of the folders in $PATH.<br /><br />Let's do it with an example. Assuming we have the firefox extracted in a folder and located on system somewhere like:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /><blockquote class="tr_bq"><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /media/F/Setups/Linux/Web/Firefox/firefox</i></blockquote>Following command will create a symlink to our binary.<br /><blockquote class="tr_bq"><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ln -s /media/F/Setups/Linux/Web/Firefox/firefox</i></blockquote>It should create a file called 'firefox' in our file folder. Remember, this is not same as copying the file, it's creating a symbolic link (shortcut). You can verify this with following command:<br /><blockquote class="tr_bq"><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file ~/firefox</i></blockquote>It's output should be like:<br /><blockquote class="tr_bq"><i>firefox: symbolic link to `/media/F/Setups/Linux/Web/Firefox/firefox'</i></blockquote><br />Then move this file to somewhere in $PATH. You'll need to use 'sudo' for that as most of the folders in $PATH are not writable for ordinary users.&nbsp;&nbsp; <br /><blockquote class="tr_bq"><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sudo mv ~/firefox /usr/local/bin</i></blockquote>WARNING: Do not create symlink with 'sudo'<br /><h4 style="text-align: left;">Adding the folder to $PATH</h4>In previous method we saw to create a command (a.k.a installed binary) by placing the symlink in a folder which was already in $PATH. But we can do it the other way. We can add the folder containing our binary to the $PATH itself.<br />Here's the command to do that for one terminal session.<br /><blockquote class="tr_bq"><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; export PATH="/path/to/binary/folder:$PATH"</i></blockquote><br />Don't forget to replace '/path/to/binary/folder' with the path to the folder that's containing your binary file.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />But this works only for current terminal session. As long as the terminal is closed, system will forget there's a command as your binary. To make it work in all terminal sessions everytime, you'll need to copy above command and place it in your '~/.bashrc' or '~/.profile' file (just put it in the end of either of the above files).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /><br /><h4 style="text-align: left;">Using <i>update-alternatives</i> command [RECOMMENDED]</h4>Well, this is a post for Linux newbies, so I assume you are using some variant of Ubuntu. Ubuntu (may be other Debian based system and may be Fedora as well) have a very useful command 'update-alternatives' that let you install alternative versions of different software and to easily configure which one you want to use.<br />As in our example case, you might have firefox already installed and re-installing the binary will do nothing but confuse the system (although it'll not get confused, but you will).<br /><br />Syntax for using above mentioned command is easy and straight forward. Consider taking a look at '<i>man update-alternatives'</i> or at least '<i>update-alternatives --help</i>'.<br /><br />What 'update-alternatives' actually do is similar to what we did in method 1. It creates a symlink to our binary file and automatically place in a folder on $PATH (we need to tell which one). But what it do extra is, make the command available to all users and keep a record of which one of many executables you gonna install under same will be available from command line.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />Here's the quick example for our use case, i.e. installing a binary.<br />Let's assume we already have firefox installed in the system, but we want to install firefox-nightly under same name (firefox that is) and switch between two whenever we want.<br />Use following command:<br /><blockquote class="tr_bq"><i>sudo update-alternatives --install /usr/local/bin firefox /path/to/firefox-nightly 1</i></blockquote><br />Here's the quick illustration of what's going on in above command:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>sudo</b> -- You need to be 'root' to use this command, so sudo<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>update-alternatives</b> -- It's the command itself<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>--install</b> -- It tells what action should be taken for updating alternative software. Here we wanna install new one.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>/usr/local/bin</b> -- It's the folder in which we want to create the symlink. It must be in the $PATH.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>firefox</b> -- It's the name under which you want to install the executable.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>/path/to/firefox-nightly</b> -- It's the path to the file which should execute on running above named command<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>1</b> -- It's the priority that should be given to the command we are installing out of other commands with same name already present on our system.&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />We now have two versions of firefox. The one which was already present and the nightly build we installed afterwards. Following command can be used whenever we want to make a switch between the software that should be run by 'firefox' command (i.e stable or nightly or whatever):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /><blockquote class="tr_bq"><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update-alternatives --config firefox</i></blockquote>It'll give a list of the firefox versions installed and you can choose whichever you want to use.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />I am sure there'll be other ways of installing binaries as well (this is GNU/Linux after all), but these are the ones I use most often (and that are on my mind right now). If you know other better ways, please do inform me, or if I am doing something wrong here or you want me to explain something better, please mention in comments. </div><hr /><br /><b><i>Circle Beat Of The Geek on</i></b> <a href="https://plus.google.com/109838896781876000861" target="_blank">Google Plus</a><br /><i><b>OR Like us on</b></i> <a href="https://www.facebook.com/pages/Beat-Of-The-Geek/251813454834549" target="_blank">Facebook</a> <b><i>&nbsp;OR Follow on</i></b> <a href="https://twitter.com/#!/beatofthegeek" target="_blank">Twitter</a></div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting up your own LAMP machine for PHP development -Setting MySql and PHP]]></title>
    <link href="http://\.github.io/\/github/2012/07/setting-up-your-own-lamp-machine-for.html"/>
    <updated>2012-07-01T00:00:00+05:30</updated>
    <id>http://\.github.io/\/github/2012/07/setting-up-your-own-lamp-machine-for</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on">&lt;&lt; Previous:&nbsp;<a href="http://channikhabra.blogspot.in/2012/06/setting-up-you-own-home-lamp-machine.html" target="">Setting up Apache</a><br /><br />Well, after setting up the apache http daemon, it's time for the database management system, the 'M' of LAMP.<br /><h3 style="text-align: left;">   </h3><h3 style="text-align: left;">    Installing MySql</h3>It can't be easier. Just shoot the terminal and type:<br /><blockquote class="tr_bq"><code>sudo apt-get install mysql-server</code></blockquote>Yup! That's it. You'll get some prompts and will be asked to enter the password for root user (root user of MySql not the Operating System). Just enter the details and that's all for the MySql.<br /><h4 style="text-align: left;">    Removing Mysql from Startup</h4>Yeah, just like Apache daemon, mysql put itself on startup too. And it will not get removed by just running update-rc.d. We need to comment out a couple lines in the mysql.conf file. So, shoot the terminal and do this.<br /><br /><!-- more --><br /><br /><ul style="text-align: left;"><li><span style="background-color: white;"><code>sudo kate (or gedit) /etc/init/mysql.conf</code></span></li><li><span style="background-color: white;">Comment out the two starting lines (they should say "start on" and something)</span></li></ul><div>That's it. MySql is now removed from the startup. To run the Mysql daemon after this, use following command</div><blockquote class="tr_bq"><code>sudo service mysql start</code></blockquote><br /><br /><h3 style="text-align: left;">    Installing PHP5</h3>After we've set Apache and MySql, it is time for the real sexy. Although PHP can be installed via Ubuntu packages with <i>apt-get install php5</i>, but it will install php5.3(.something). That's no good as we wanna use the latest version. Remember I told you about the inbuilt server provided with php that almost eliminates the need for the Apache server in development environment? It come with PHP5.4 and is not available in PHP5.3. Beside that there are many more <a href="http://php.net/releases/5_4_0.php" target="_blank">awesome features</a> which make it worth installing. So let's install the latest version of PHP.<br /><h3 style="text-align: left;">    Installing Latest PHP in Ubuntu</h3>Shoot the terminal and enter following commands:<br /><blockquote class="tr_bq"><code>sudo add-apt-repository ppa:ondrej/php5</code></blockquote>And then update apt-get repository info and install apache php mod, php5 itself and php mysql extension to use mysql with php.<br /><blockquote class="tr_bq"><code>sudo apt-get update<br />sudo apt-get install php5 libapache2-mod-php5 php5-mysql</code></blockquote><h4 style="text-align: left;">    <span style="background-color: white;">Running PHP server (not Apache)</span></h4>To run the php server instead of Apache, just run following command in terminal.<br /><blockquote class="tr_bq"><code>php -S localhost:8080</code></blockquote>This will run a server listening at port 8080. So, we'll need to go to <a href="http://localhost:8080/">http://localhost:8080</a>&nbsp;to run the server. In order to run the server as simply <a href="http://localhost/">http://localhost</a>, we'll need to run the server at port 80, and for that we need to run the above command with sudo and 80 instead of 8080. Here's what I mean:<br /><blockquote class="tr_bq"><code>sudo php -S localhost:80</code></blockquote><h3 style="text-align: left;">    <span style="background-color: white;">Benefits of using PHP Server</span></h3><br /><ul style="text-align: left;"><li><span style="background-color: white;">PHP server run as the current working directory as the root server dir. So there is no need to go through the hassle of creating different sites in apache.</span></li><li><span style="background-color: white;">Running php server helps a lot in debugging by displaying all the messages, errors and warnings in the terminal itself. So no need to change php.ini to enable debugging or use some other method.&nbsp;</span></li><li><span style="background-color: white;">It is really cool to use it (don't know why, but I feel like it is cool :P)</span></li></ul><div>Here's a snapshot of how it look when running php server.<br /><br /><br /></div><div><span id="goog_2392878"></span><span id="goog_2392879"></span></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-_raAYxZsmQI/T_Ad5Kwo0CI/AAAAAAAAAQk/gUaZ2-1J7ho/s1600/snapshot1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="205" src="http://2.bp.blogspot.com/-_raAYxZsmQI/T_Ad5Kwo0CI/AAAAAAAAAQk/gUaZ2-1J7ho/s400/snapshot1.png" width="400" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"></div><br /></div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting up your own home LAMP machine for PHP development -Setting Apache]]></title>
    <link href="http://\.github.io/\/github/2012/06/setting-up-you-own-home-lamp-machine.html"/>
    <updated>2012-06-30T00:00:00+05:30</updated>
    <id>http://\.github.io/\/github/2012/06/setting-up-you-own-home-lamp-machine</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on"><div style="text-align: justify;">Hello there!!</div><div style="text-align: justify;">Well am back here after a long time. Writing blog posts is really boring when you have something as awesome as writing code, and writing code for web applications is what is red hot in the skies right now. So here's this post to help us setting up our own LAMP (Linux - which all of us already have, Apache - the HTTP server, MySql - the Database Management System, and PHP - the sexy thing we'll write our web apps in).&nbsp;</div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: right; margin-left: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><a href="http://www.ezeelive.com/cmsAdmin/uploads/php_web_developer_mumbai_india_ezeelive.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="225" src="http://www.ezeelive.com/cmsAdmin/uploads/php_web_developer_mumbai_india_ezeelive.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Php Development in Linux</td></tr></tbody></table><div style="text-align: justify;">Yea I know it is dead easy to just use the <a href="http://sourceforge.net/projects/lampas/" target="_blank">LAMP</a> (like people use <a href="http://www.wampserver.com/en/" target="_blank">WAMP</a> on <a href="http://forums.opensuse.org/english/other-forums/community-fun/general-chit-chat/461353-10-reasons-why-windows-still-sucks.html" target="_blank">Windows</a>), but what's the meaning of using something as awesome as Linux if we are gonna use those tools<span style="background-color: white;">(no offenses here)</span><span style="background-color: white;">. I hate using LAMP anyways.</span></div><div style="text-align: justify;"><span style="background-color: white;">So what we gonna do is installing Apache, Mysql and PHP on our machine and setting it up for awesome developing PHP apps.</span></div><!-- more --><br /><h3 style="text-align: justify;">   <span style="background-color: white;">Installing Apache</span></h3><div style="text-align: justify;"><span style="background-color: white;">Well, it can't be done easier on our Ubuntu Machine.</span></div><blockquote class="tr_bq" style="text-align: justify;"><span style="background-color: white;"><code>sudo apt-get install apache2</code></span></blockquote><div style="text-align: justify;">Installing apache is easy enough, but I don't think we gonna use our machine for web development all the time, are we? By default apache puts itself into the startup applications list, i.e. it starts up everytime we boot up. That's a kind of overkill for our development environment. But it is easy to remove it from startup.</div><h4 style="text-align: justify;">   Removing Apache from Startup</h4><div style="text-align: justify;">Just launch the terminal console (alt+ctrl+T on Gnome) and execute the following command</div><blockquote class="tr_bq" style="text-align: justify;"><code>sudo update-rc.d apache2 disable</code></blockquote><div style="text-align: justify;">Now Apache will not start on the startup. We'll need to start it manually everytime we gonna use it. Just use following command to <b>start apache http server:</b>&nbsp;</div><blockquote class="tr_bq" style="text-align: justify;"><code>sudo /etc/init.d/apache2 start</code> OR<span style="background-color: white;">&nbsp;</span></blockquote><blockquote class="tr_bq" style="text-align: justify;"><code>sudo service apache2 start</code></blockquote><h4 style="text-align: justify;">   Changing www (default directory) in Apache</h4><div style="text-align: justify;">By default Http server runs and show those files in <i>http:/localhost </i>which are located in the /var/www directory. But many times we need to change that directory to something else like ~/www or anything so as to run the server with that site as root.&nbsp;</div><div style="text-align: justify;">To achieve this in apache, we need to follow these steps:</div><br /><ul style="text-align: left;"><li style="text-align: justify;">Go to <i>/etc/apache2/sites-available</i> directory</li><li><div style="text-align: justify;"><span style="background-color: white;">Copy the file named </span><i style="background-color: white;">default </i><span style="background-color: white;">into the same (</span><i style="background-color: white;">/etc/apache2/sites-available</i><span style="background-color: white;">) directory and rename it to whatever (say 'www' this time) OR use this command via terminal</span></div><span style="background-color: white;"><div style="text-align: justify;"><span style="background-color: white;"><code>cp&nbsp;</code></span><code><i style="background-color: white;">/etc/apache2/sites-available/default&nbsp;</i><i style="background-color: white;">/etc/apache2/sites-available/www</i></code></div></span><i style="background-color: white;"><div style="text-align: justify;"><br /></div></i></li><li><div style="text-align: justify;"><span style="background-color: white;">Open up the 'www' file we created in text editor OR use this command via terminal</span></div><i style="background-color: white;"><div style="text-align: justify;"><i style="background-color: white;"><code>kate (or gedit) /etc/apache2/sites-available/www</code></i></div></i></li></ul><ul style="text-align: left;"><li style="text-align: justify;">Find and replace "/var/www" with the path we wanna use as our server root, say "/home/dante/www"</li></ul><div style="text-align: justify;">And that's all for the tough part. Now we have created a different site which we can enable or disable via command line anytime. This give us the power to use multiple server roots and switch between them easily.</div><div style="text-align: justify;">To enable our new site (i.e. to change the server root dir), enter following command in terminal</div><blockquote class="tr_bq" style="text-align: justify;"><code>sudo a2ensite www</code></blockquote><div style="text-align: justify;">But before that we need to disable already enabled default site, to disable it run</div><blockquote class="tr_bq" style="text-align: justify;"><code>sudo a2dissite default</code></blockquote><div style="text-align: justify;">Simple enough, huh!<br />Well I can't agree more that this is quite a hassle to just changing server root dirs. But here's an alternative.<br /><b>Alternatively, </b>we can create a virtualhost.<br />For this, we'll edit the default &nbsp;file in /etc/apache2sites-available/ and also the /etc/hosts file. Then we'll give different projects different URIs (that will be accessible only to your computer) and use those URIs instead of 127.0.0.1 or something. For example, for a project called 'php-project', we'll assign phpproject.dev (can be anything) and enter http://phpproject.dev in browser to see our project.<br />Here's how we do it.<br /><br /><b>CREATE VIRTUAL HOST:</b><br /><br /><ul><li>Change directory to /etc/apache2/sites-available<br /><span style="font-family: Courier New;"><i>cd /etc/apache2/sites-available</i></span></li><li><span style="font-family: Courier New;">Open 'default' in editor<br /><i>sudo gedit&nbsp;</i></span><span style="font-family: Courier New;">/etc/apache2/sites-available/default</span></li><li><span style="font-family: 'Courier New';">Enter following at the end of file&nbsp;</span><i><virtualhost><br /></virtualhost></i><i>&nbsp;&nbsp;</i>DocumentRoot "/home/[username]/phpProject/" <br />&nbsp; ServerName phpproject.dev <i>&nbsp; &nbsp;&nbsp;</i></li></ul></div><br /><br />Here, DocumentRoot is the location of your project ([username] is your username, like 'channi'), and phpproject.dev is the name you want to access the project with (its local browser address)<br /><br /><b>EDIT /etc/hosts</b><br /><div style="text-align: justify;"><ul><li>Open /etc/hosts in editor<br /><i>sudo gedit /etc/hosts</i></li><li>Enter following line at the end<br /><i>0.0.0.0 &nbsp;phpproject.dev</i><br /><br />(phpproject.dev can be anything like iamawesome.com or whatever, but keep it same as ServerName in /etc/apache2/sites-available/defautl file)</li></ul><div>And that's it. You can now simply open up your browser and go to phpproject.dev, and your project is there for you.</div><br /><br /></div><div style="text-align: justify;">Wish there was an easy way. If you are thinking the same, then congrats actually, php5.4 comes with an inbuilt server script which can solve many of our problems and provide a nice and easy way to debug php apps. We'll talk about it shortly. &nbsp;</div><div style="text-align: justify;">So let's <a href="http://channikhabra.blogspot.in/2012/07/setting-up-your-own-lamp-machine-for.html">setup Mysql and PHP</a>.</div><div style="text-align: justify;"><a href="http://channikhabra.blogspot.in/2012/07/setting-up-your-own-lamp-machine-for.html" target="">&gt;&gt;NEXT&gt;&gt;</a></div></div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Download in Geek Style: Use Wget (Part 2)]]></title>
    <link href="http://\.github.io/\/github/2011/08/download-in-geek-style-use-wget-part-2.html"/>
    <updated>2011-08-21T00:00:00+05:30</updated>
    <id>http://\.github.io/\/github/2011/08/download-in-geek-style-use-wget-part-2</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on">Hello there ! !<br />After our last <a href="http://channikhabra.blogspot.com/2011/08/download-in-geek-style-use-wget-part-1.html">article on Introduction to wget for Linux newbies</a>, it is time to advance a little further. In this article &nbsp;we'll discuss advanced usage of Wget.<br />Let's start with Wget's most wanted command:<br /><br /><span class="Apple-style-span" style="font-size: 19px; font-weight: bold;"><b><span class="Apple-style-span" style="color: #6aa84f; font-size: small;"></span></b></span><br /><b><span class="Apple-style-span" style="color: #6aa84f;">Downloading Recursively (-r switch)</span></b><br /><div><span class="Apple-style-span" style="color: #6aa84f;"><b><br /></b></span>Wget can download recursively, following all the links it meet in the way of downloading process. For example, you are reading an online book (ebook of course), which has links to further chapters. Using this command you can easily download all the pages of the ebook with a single command making your own copy of the ebook to be read offline. Even better, doing some Google we can download as many mp3s or other files as we want, all in a single command.<br />Excited ? (I know you are)<br />All right, enough talking.<br /><span class="Apple-style-span" style="color: #6aa84f; font-weight: bold;"></span><br /><hr /><br /><!-- more --><br /><br /><span class="Apple-style-span" style="color: #6aa84f; font-weight: bold;"><span class="Apple-style-span" style="font-size: large;">How to download recursively</span></span><br /><br /><code> wget -r -l 7 --no-parent&nbsp;</code><span class="Apple-style-span" style="font-family: monospace;">-A pdf,djvu&nbsp;</span><span class="Apple-style-span" style="font-family: monospace;">-nH --cut-dirs=4 -P "My download directory" "Link to download page"&nbsp;</span><br />&nbsp;<b>Time for some explanations:</b><br /><b><span class="Apple-style-span" style="color: #6aa84f;">-r or --recursive</span>&nbsp; &nbsp;</b>This switch tell wget to start downloading recursively from the link given.<br /><br /><b><span class="Apple-style-span" style="color: #6aa84f;">-l or --level='depth'</span></b> &nbsp; &nbsp;When downloading recursively, wget follows a system of levels. This denotes the levels of depth to which wget will follow links.<br />As in above example when we start a download from page 1 with level stated to be 7, wget download main page first. After this it follows all the links given on the page. This is level one. After downloading everything, wget starts following links given in downloaded pages. This is level 2. Similarly wget will download everything &nbsp;following every link it meet in the way until it reaches maximum depth.<br />By default, wget sets depth level to be 5. It can also be set to infinite<br /><blockquote><code>wget -r -l inf "download link" </code> or <code>wget -r l 0 "link"</code></blockquote><br /><span class="Apple-style-span" style="color: #6aa84f;"><b>--no-parent or -np </b></span>&nbsp; Wget's recursive download is bidirectional. It means wget follows link in both directions of link&nbsp;hierarchy (err... what is that?).<br />Let's see an example. Assume we are downloading free ebooks from a website, say example.com/ebooks/english/list.html . So&nbsp;&nbsp;what we want is downloading English books only. But by default, wget will follow all links on list.html BUT it will also move upwards and follow links it find there. This is not what we want.<br />SO here is --no-parent. It is a very useful command which ensures that we download only downwards the hierarchy and don't go upwards. <br /><br /><span class="Apple-style-span" style="color: #6aa84f;"><b>Download specific file types (-A 'filetype or list' or --accept="list of filetypes")</b></span> &nbsp; &nbsp;When downloading ebooks from our kind website, we don't want any HTML,CSS or Javascript files to be downloaded. By default, wget will download everything including images, scripts &nbsp;and everything. -A or --accept switch allow us to download only desired files. In the example, we want only .pdf and .djvu files to be downloaded, and wget will do that, strictly following our orders. Multiple filetypes can be given separated by commas.<br /><br /><span class="Apple-style-span" style="color: #6aa84f;"><b>-R "list of filetypes" or --reject="filetypes"</b></span> &nbsp; Similar to -A is -R. While -A accepts some files and rejects others -R, rejects some given filetypes and download everything else.<br /><br /><span class="Apple-style-span" style="color: #6aa84f;"><b><u>Handling Directories</u></b></span><br /><br /><span class="Apple-style-span" style="color: #6aa84f;"><b>-P "path" or --directory-prefix="path" </b></span>&nbsp; As stated in <a href="http://channikhabra.blogspot.com/2011/08/download-in-geek-style-use-wget-part-1.html">previous article</a>, -P can be used to redirect downloaded file to some specific path.<br /><br />But when downloading recursively, there is one problem. Wget saves all the files in the same directory hierarchy as they were on the server. As in our example, by default all files will be saved as this,<br /><blockquote>&nbsp;Home Folder&gt; example.com &gt; ebooks &gt; english&gt; file.pdf</blockquote>This behavior can be very irritating for normal users like us. But no worries, wget provides many options to handle this our own way. Here are some most commonly used ones.<br /><br /><span class="Apple-style-span" style="color: #6aa84f;"><b>--cut-dirs=x </b></span>&nbsp; &nbsp;This is useful command for controlling the directory structure of the location where recursively downloaded files will be saved. It cut the "x" directory components from the hierarchy.<br /><br /><span class="Apple-style-span" style="color: #6aa84f;"><b>--nH or --no-host-directories</b></span> &nbsp; &nbsp;This command cuts the name of host from directory structure. In other words, it disables generation of host prefixed directories.<br /><br /><span class="Apple-style-span" style="color: #6aa84f;"><b>-nd or --no-directories</b></span> &nbsp; It suggests wget to not to use any directory structure at all and save all the files in open (by default) or in the folder specified by -P command.<br /><br /><b>Example:</b><br />Assume that we are recursively downloading (pdf) files from example.com/ebooks/english, then this is how they will be saved on our PC with different commands...<br /><br /><blockquote>No options &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;example.com/ebooks/english/file.pdf<br />-nH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ebooks/english/file.pdf<br />-nH --cut-dirs=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;english/file.pdf<br />--cut-dirs=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;example.com/english/file.pdf</blockquote>Got it ?....Good... : )<br /><br /><span class="Apple-style-span" style="color: #6aa84f;"><b>Making readable Offline Copies of Websites</b></span><br /><span class="Apple-style-span" style="color: #6aa84f;"><b><br /></b></span>It is really easy to make offline copies of websites, just start a recursive download and it is done. No it is not.<br />&nbsp;Think of the links given on pages. For example, if we download an ebook (HTML files) which has links to next chapters and other such links, all of them point to pages available on server, like &nbsp;an ebook at "example.com/onlinebook/contents" will have link to chapter 1 like this, "example.com/onlinebook/chapter1". Even in an offline copy (that we have made using wget), clicking on this link will take us online to the server. But this is not what we want.<br /><div>Again, no worries, wget has a solution for this.</div><div><br /></div><div><span class="Apple-style-span" style="color: #6aa84f;"><b>-k or --convert-links</b></span>&nbsp; &nbsp; This is an extremely useful option which converts all the links in downloaded pages to their local copies (if they are downloaded). In case HTML files have link to the content which has not been downloaded, wget will convert those links to their absolute location (internet of course). This ensures that there are no broken links and make local viewing smooth.</div><div><br /></div><div><span class="Apple-style-span" style="color: #6aa84f;"><b>-p or --page-requisites </b></span>&nbsp; &nbsp; As all other wget commands, this is also a very useful command which help to download all the files which are necessary for proper display of a page. It downloads everything (images, sounds, style sheet references etc) which are necessary for proper display of page even if they are located on different websites.<br /><br /><b><span class="Apple-style-span" style="color: #6aa84f; font-size: large;">When She said NO !!</span></b><br /><br />Sometimes web servers don't allow tools like wget to access &nbsp;their data and hence we can't download from such servers. But as I am saying from very&nbsp;<a href="http://channikhabra.blogspot.com/2011/08/download-in-geek-style-use-wget-part-1.html">beginning</a>, wget has a way for everything (almost). Here are some useful commands which can be used to get access when the server says no and tempt to kick your ass.<br /><br /><span class="Apple-style-span" style="color: #6aa84f;"><b>-U "agent" or --user-agent="agent" </b></span>&nbsp; &nbsp;When wget access a file on a HTTP server, it identifies itself by sending a user agent string (header field). It is like it says to server, "Hey baby, this is wget. Wassup ?". But sometimes HTTP servers deny connections to some agents (web browser, wget etc are all agents which allow us access Internet through protocols) or only allow some specific agents to access their data. We can fool the server by changing the user agent string. The command looks like this:<br /><blockquote><code>wget -U "Mozilla/5.0"</code>&nbsp;or&nbsp;<code>wget --user-agent="Mozilla/5.0"</code></blockquote>Here Mozilla is name of agent and 5.0 is version number. What we are doing is, changing user ID to look as if it was sent by your browser or at least hide the fact that it is sent by wget.<br />Actual User ID string is &nbsp;pretty long and carry more information, but this much is fine for fooling most web servers. We can also say wget to not to send any user ID with this command:<br /><blockquote><code>wget --user-agent=""</code>&nbsp; &nbsp;</blockquote><span class="Apple-style-span" style="color: #6aa84f;"><b>--referer=url </b></span>&nbsp; &nbsp;This command includes the "Referer: url" in the HTTP request. Sometimes servers expect that their data is always accessed by web browsers which are always sent by some page which points to them. This command is not used often, but may be useful in some particular case.<br /><br /><span class="Apple-style-span" style="color: #6aa84f;"><b>--http-user=user and --http-password=password</b></span> &nbsp; In case you have an account on the server and server needs username and password to authenticate the request, these commands are to be used. Similar commands are <b>--ftp-user=user</b> and <b>--ftp-password=password</b> for ftp servers and <b>--user=user</b> and <b>--password=password</b> for both http and ftp servers. Latter two have lower preference than first two command sets.<br /><br /><span class="Apple-style-span" style="color: #6aa84f;"><b>-w seconds or --wait=seconds </b></span>&nbsp; &nbsp; This command wait for given number of seconds between two consecutive downloads thus decreasing the load on the server. Instead of in seconds, time can be given in minutes with "m" suffix or in hours or even in days with "h" and "d" suffices. Large values can be useful in case destination server is down, giving wget enough time to retry and wait till it is up again.<br /><br /><span class="Apple-style-span" style="color: #6aa84f;"><b>--random-wait </b></span>&nbsp; Sometimes, web servers do analyse the traffic coming to them and find out if automatic tools like wget access them. They usually count the time between requests they&nbsp;receive&nbsp;and deny further requests, --random-wait switch allows us to make wget wait for random time between&nbsp;consecutive&nbsp;downloads and fooling the server.<br />This option causes the&nbsp;time between requests to vary between 0.5 and 1.5 * wait seconds,where wait was specified using the --wait option, in order to mask&nbsp;Wget's presence from such analysis.<br /><div><br /></div><div><span class="Apple-style-span" style="color: #6aa84f;"><b>Unleash the power of Google</b></span><br /><span class="Apple-style-span" style="color: #6aa84f;"><b><br /></b></span></div>Google too has a syntax like *nix commands, which can be used for finding desired results from over billions of pages on Internet. We can get just what we want if we use it smartly. Here we want a pure list of downloadable files, which we can download with wget. Just enter this string in Google Search Bar and hit enter:</div><div><blockquote><i>intitle:"index of/" mp3 "your favorite band" parent directory</i></blockquote>This will give links to pages which only have links to mp3 files of your favorite band ready to download. This link can be passed to wget for a recursive download with required recursion depth to&nbsp;successfully&nbsp;get what we want. Tinker with above search string to get other kind of stuff, may be videos, ebooks or whatever.<br />(This is meant for educational purposes only. Downloading this way is not legal. Use at your own risk... :P)<br /><br />Wget has much more than this. Refer to wget manual pages for more advanced and&nbsp;insight&nbsp;information.<br />HAPPY HACKING... :D<br /><br /><hr style="text-align: justify;" /><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><b><i>Circle Beat Of The Geek on</i></b>&nbsp;<a href="https://plus.google.com/109838896781876000861" target="_blank">Google Plus</a></div><div style="text-align: justify;"><i><b>OR Like us on</b></i>&nbsp;<a href="https://www.facebook.com/pages/Beat-Of-The-Geek/251813454834549" target="_blank">Facebook</a>&nbsp;<b><i>&nbsp;OR Follow on</i></b>&nbsp;<a href="https://twitter.com/#!/beatofthegeek" target="_blank">Twitter</a></div></div></div></div></div>

]]></content>
  </entry>
  
</feed>
