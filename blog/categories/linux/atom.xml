<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | Beat of The Geek]]></title>
  <link href="http://beatofthegeek.com/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://beatofthegeek.com/"/>
  <updated>2014-02-20T17:47:08+05:30</updated>
  <id>http://beatofthegeek.com/</id>
  <author>
    <name><![CDATA[Charanjit Singh]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[git commit illustrated: Simplicity revealed by a complex exercise for simplest git task]]></title>
    <link href="http://beatofthegeek.com/2014/01/git-commit-illustrated-simplicity.html"/>
    <updated>2014-01-10T00:00:00+05:30</updated>
    <id>http://beatofthegeek.com/2014/01/git-commit-illustrated-simplicity</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on"><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-2hJwSV2bj7I/Us-k_1d6bnI/AAAAAAAAAlQ/FplZr00hLCk/s1600/46.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-2hJwSV2bj7I/Us-k_1d6bnI/AAAAAAAAAlQ/FplZr00hLCk/s1600/46.png" height="236" width="400" /></a></div>In this post I will try to explain the underlying commands and to a level the internal working of the git system involved when making a 'commit'.<br />This post is actually the by-product of my research for another post about git (.git/ actually).  I was so much astonished by the amount of myths about complexity of git system removed from my mind, that I decided to make it the today's post itself. To me the git system appears much simple now than yesterday.<br /><h3 style="text-align: left;">Commit </h3>Commit is the central piece of the git system. The git world is simply a collection of commit objects, each of which hold a tree, which hold references to other trees and blobs. The branches, the tags, the HEAD are just fancy aliases for commits (more on these in some other post (next may be)).<br />A commit is basically the snapshot of present working tree. I will spare the details  for a future post (it's worth it).<br /><br />Let's now discuss what this post is about. Revealing the secrets involved in every git users ritual of 'commit'ing, and performing a commit manually.<br /><br /><!-- more -->This should reveal quite some details about the internal working of git (no you don't need to run away, it's not that deep).<br /><br />You might already know the concepts, but knowing sex and having sex are kind of different things.<br /><br />Ok! Let's start the <b>exercise for manual commit</b>.<br /><br />First we need to create an empty directory, call it 'work'. And some simple file in it.<br /><blockquote class="tr_bq">=&gt; mkdir work<br />=&gt; echo "Hello world!" &gt; hello_world</blockquote>Initiate a git repo in it and add the 'hello_world' file<br /><blockquote class="tr_bq">=&gt; git init</blockquote>We will keep an eye on the changes that happen in the '.git' repo throughout our exercise. For now check out what's saved in the HEAD.<br /><blockquote class="tr_bq">=&gt; cat .git/HEAD<br />=&gt; ref: refs/heads/master</blockquote>As HEAD is basically just a reference to the commit which represents the current commit associated with the working tree. So one might guess .git/refs/heads/master would point to the tip of a branch. Let's check it <br /><blockquote class="tr_bq">=&gt; ls .git/refs/heads/master<br />=&gt; <br />=&gt; git branch<br />=&gt;</blockquote>There is nothing in there. Since we have not committed any commits yet, there are no branches (since branches are merely named commits which happen to have multiple child commits).<br />If you are feeling adventurous, you can try 'git log'.<br /><blockquote class="tr_bq">=&gt; git log<br />=&gt; fatal: bad default revision 'HEAD'</blockquote>Let's now <b>add our file to the staging area</b><br /><blockquote class="tr_bq">=&gt; git add hello_world</blockquote><blockquote class="tr_bq"><b>Staging area is the middle system which keeps our content after 'git add' and before 'git commit'</b></blockquote><blockquote class="tr_bq">&nbsp;<b>A blob is the git's representation of a file. It's not actually a file, but just the content. A blob do not have any name or other metadata. It's referenced in trees which contain metadata for blobs.<br />Tree is the object which stores references to other trees and blobs as leaf nodes.</b></blockquote>This command converted content of 'hello_world' file into a blob and placed it in the index (aka staging area). A 'blob' is how our content is represented in git. You can check the .git dir, a new file 'index' is created. This file contain the references to all blobs and trees which get added to our staging area.<br /><blockquote class="tr_bq">=&gt; ls .git<br />=&gt; branches&nbsp; config&nbsp; description&nbsp; HEAD&nbsp; hooks *index*&nbsp; info&nbsp; objects&nbsp; refs</blockquote>At this point we would generally just 'commit' the 'index', but not this time. The 'git commit' command hides many details and is a great convenience. You'll value it after this exercise.<br /><br />Git store all our content in form of blobs. The blobs do not have any kind of meta-data attached with them (like name, creation date or something). They are just nameless 'blobs'. To identify a blob, they are saved in 'trees' as leaf nodes. Different trees can save reference to same blob with different meta-data attached. But a git repository will have exactly one copy of a blob. This is the reason of compact storage of git.<br /><br />We can see the blob for our content in 'hello world' present in staging area (index)<br /><blockquote class="tr_bq">=&gt; git ls-files --stage<br />=&gt; 100644 802992c4220de19a90767f3000a79a31b98d0df7 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hello_world</blockquote>If you entered the same content as me, both your and my hashes should be same. We can check what type of object the above hash belong to<br /><blockquote class="tr_bq">=&gt; git cat-file -t 802992c<br />=&gt; blob</blockquote>The above blob is not referenced by any tree. It's only referenced from .git/index (which store references to objects (blobs and trees) which make up our staging area).<br />&nbsp;A 'commit' object in git holds a single tree. A tree may have references to more trees or blobs. So to 'commit' the above created blob of our content, we need a tree. <br /><br />So we now need to create a tree. <br /><blockquote class="tr_bq">=&gt; git write-tree<br />=&gt; cdbf8e1f00e97366e01cbf2d73f3689a60107686</blockquote>'write-tree' command make a tree with the contents of the 'index'.<br />Now when we have the tree, let's create a commit object with it.<br /><blockquote class="tr_bq">=&gt; echo "Initial commit" | git commit-tree cdbf8e1<br />=&gt; a5a86835ba72e3ca7d5267c68c06c212392f9b7d</blockquote>That's the hash for our commit object. You directly use 'git commit <tree-hash>'. Then the command will wait for the commit message to be entered and 'ctrl-d' for proceeding.</tree-hash><br /><br />So our commit object is ready, and we are done. Right? Not actually. What we have created is called an 'unreachable commit'. <br /><b>An unreachable commit</b> is a commit which do not have any parents and which is not referenced by any of the files in .git/refs/heads/. Such commits are automatically removed by the git system after some time.<br />&nbsp;To make our commit reachable, we need to create a reference in a file in .git/refs/heads. <br /><blockquote class="tr_bq">=&gt; echo a5a86835ba72e3ca7d5267c68c06c212392f9b7d &gt; .git/refs/heads/hello</blockquote>Actually we should instead use the more safe way to update references in git system.<br /><blockquote class="tr_bq">=&gt; git update-refs refs/head/hello a5a86835ba72e3ca7d5267c68c06c212392f9b7d</blockquote>Here if we had used name 'master' instead of 'hello', we could have used 'git log'. But now it's still giving 'fatal:' because the HEAD is referring to 'refs/heads/master' which does not exist.<br /><br />Now try the command 'git branch'.<br /><blockquote class="tr_bq">=&gt; git branch <br />=&gt; hello</blockquote>Here we see what a branch actually is to git. A reference to a 'commit' object.<br />Wait there is more to it. Now when we have created the branch 'hello', we need to make HEAD refer to it. <br /><blockquote class="tr_bq">=&gt; git symbolic-ref HEAD refs/heads/hello</blockquote>This command associated our working tree with the newly created branch/commit of ours. This is what actually happens on a checkout normally.<br />Now we can use 'git log'. If you are using 'zsh' with appropriate theme, at this point the git branch indicator will change form uncommitted 'master' to committed 'hello'.<br /><br />Now we are done. Officially. Git system is this frighteningly simple inside. Hope this was as helpful for you as it was for me. I really enjoyed writing this post.</div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to setup postgresql (python-flask) app on Heroku and local machine]]></title>
    <link href="http://beatofthegeek.com/2013/04/how-to-setup-postgresql-python-flask.html"/>
    <updated>2013-04-30T00:00:00+05:30</updated>
    <id>http://beatofthegeek.com/2013/04/how-to-setup-postgresql-python-flask</id>
    <content type="html"><![CDATA[<div class='post'>
<a href="http://b.vimeocdn.com/ps/245/288/2452886_300.jpg" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" src="http://b.vimeocdn.com/ps/245/288/2452886_300.jpg" /></a>So I was like setting up a python web app on Heroku cloud platform and it was awesome. You don't need to break a sweat to deploy something like a ROR app but things are different when it come to micro-frameworks like Python-flask.<br />I chose flask for the beauty and simplicity, and because I wanted to do everything myself. The app has postgres-sql as it's database backend. Deploying apps on Heroku is easy and all but there are some things which are not that easy to find in official docs and tutorials. <br />So here we shall proceed with setting up postgres (with Python) on Heroku.<br /><!-- more --><br /><h3>Install flask-sqlalchemy and psycopg2</h3>Since we are using python we need these libraries for accessing the services. flask-sqlalchemy is a flask extension for the infamous sqlalchemy library and we need psychopg2 to interact with the postgres itself.<br />If you are using other language the you obviously need to use relative tools.<br />Above libraries can be installed with<br /><blockquote class="tr_bq"><i>pip install flask-sqlalchemy psychopg2</i></blockquote>on your local setup. Then do <br /><blockquote class="tr_bq"><i>pip freeze &gt; requirements.txt</i></blockquote>This will put the newly installed libraries in requirements.txt file so they will get automagically installed on your Heroku instance when you push the code.<br /><br /><h4>Might need to install this on local machine to compile psycopg2</h4><blockquote class="tr_bq"><i>python-dev</i></blockquote>Before installing <i>psycopg2</i> on your local setup, you should install python-dev tools on your local linux box.<br /><br /><h3>Add heroku postgres-dev addon (it provide 10k rows for free)</h3>Heroku provides the database service as an addon to the standard platform. So we need to add the addon to our setup to use postgres.<br /><br />Run this command on your local terminal (obviously you need to have heroku-belt installed)<br /><br /><blockquote class="tr_bq"><i>heroku addons:add heroku-postgresql:dev</i></blockquote><br /><h3>After this the database is setup, now promote it to $DATABASE_URL</h3>Database is now setup. But remember how we access the database on non-cloud (traditional they call it) services? Yes, we need the url to access database (it's something like "<i>postgresql://pguser:password/dbname</i>"). Heroku creates an environment variable with a color name (you will see it when you add the addon).<br />We need to use heroku-belt's <i>pg:promote</i> command to enable $DATABASE_URL environment variable.<br /><blockquote class="tr_bq"><i>heroku pg:promote HEROKU_POSTGRESQL_COLOR</i></blockquote><h3>Now set <i>SQLALCHEMY_DATABASE_URI</i> in flask app </h3>Now we have the database URI. We need to access it in the database. We can do this by simply accessing the $DATABASE_URL environment variable. This is how to do it with a flask app.<br /><blockquote class="tr_bq"><i>SQLALCHEMY_DATABASE_URI = os.environ.get("DATABASE_URL","postgresql://pguser:password/dbname")</i></blockquote><br />This has an extra hack for accessing the local database. It loads heroku database url in heroku and local url in local dev environment. You obviously need to modify it with your local setup.<br />Another way to use local database is to export the local database URI to the shell environment. Put this line in your <i>.zshrc</i> or <i>.bash_profile</i> (depending on the shell you are using)<br /><blockquote class="tr_bq"><i>export DATABASE_URI="postgresql://pguser:password/dbname"</i></blockquote><h3>Create the postgres database on heroku </h3>Here's the python flask specific stuff now. In flask, unless you are using something like '<i>alembic</i>' for database migrations, you can directly create your database on Heroku. <br /><br />Just run python console attached to your Heroku instance<br /><blockquote class="tr_bq"><i>heroku run python</i></blockquote>Then do import your flask-sqlalchemy instance and create the database with<br /><blockquote class="tr_bq"><i>&gt;&gt;&gt;</i> <i>db.create_all</i></blockquote>assuming that 'db' is the flask-sqlalchemy instance.<br /><br /><br />So here we are with our heroku app ready to rock the postgres.<br /><br /><i>(Phewww...I eventually managed to write a post after so long. Such relief.)</i><br /><div style="text-align: justify;"><br /><br /><hr /><br /><b><i>Circle Beat Of The Geek on</i></b> <a href="https://plus.google.com/109838896781876000861" target="_blank">Google Plus</a><br /><i><b>OR Like us on</b></i> <a href="https://www.facebook.com/pages/Beat-Of-The-Geek/251813454834549" target="_blank">Facebook</a> <b><i>&nbsp;OR Follow on</i></b> <a href="https://twitter.com/#!/beatofthegeek" target="_blank">Twitter</a></div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting up your own LAMP machine for PHP development -Setting MySql and PHP]]></title>
    <link href="http://beatofthegeek.com/2012/07/setting-up-your-own-lamp-machine-for.html"/>
    <updated>2012-07-01T00:00:00+05:30</updated>
    <id>http://beatofthegeek.com/2012/07/setting-up-your-own-lamp-machine-for</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on">&lt;&lt; Previous:&nbsp;<a href="http://channikhabra.blogspot.in/2012/06/setting-up-you-own-home-lamp-machine.html" target="">Setting up Apache</a><br /><br />Well, after setting up the apache http daemon, it's time for the database management system, the 'M' of LAMP.<br /><h3 style="text-align: left;">   </h3><h3 style="text-align: left;">    Installing MySql</h3>It can't be easier. Just shoot the terminal and type:<br /><blockquote class="tr_bq"><code>sudo apt-get install mysql-server</code></blockquote>Yup! That's it. You'll get some prompts and will be asked to enter the password for root user (root user of MySql not the Operating System). Just enter the details and that's all for the MySql.<br /><h4 style="text-align: left;">    Removing Mysql from Startup</h4>Yeah, just like Apache daemon, mysql put itself on startup too. And it will not get removed by just running update-rc.d. We need to comment out a couple lines in the mysql.conf file. So, shoot the terminal and do this.<br /><br /><!-- more --><br /><br /><ul style="text-align: left;"><li><span style="background-color: white;"><code>sudo kate (or gedit) /etc/init/mysql.conf</code></span></li><li><span style="background-color: white;">Comment out the two starting lines (they should say "start on" and something)</span></li></ul><div>That's it. MySql is now removed from the startup. To run the Mysql daemon after this, use following command</div><blockquote class="tr_bq"><code>sudo service mysql start</code></blockquote><br /><br /><h3 style="text-align: left;">    Installing PHP5</h3>After we've set Apache and MySql, it is time for the real sexy. Although PHP can be installed via Ubuntu packages with <i>apt-get install php5</i>, but it will install php5.3(.something). That's no good as we wanna use the latest version. Remember I told you about the inbuilt server provided with php that almost eliminates the need for the Apache server in development environment? It come with PHP5.4 and is not available in PHP5.3. Beside that there are many more <a href="http://php.net/releases/5_4_0.php" target="_blank">awesome features</a> which make it worth installing. So let's install the latest version of PHP.<br /><h3 style="text-align: left;">    Installing Latest PHP in Ubuntu</h3>Shoot the terminal and enter following commands:<br /><blockquote class="tr_bq"><code>sudo add-apt-repository ppa:ondrej/php5</code></blockquote>And then update apt-get repository info and install apache php mod, php5 itself and php mysql extension to use mysql with php.<br /><blockquote class="tr_bq"><code>sudo apt-get update<br />sudo apt-get install php5 libapache2-mod-php5 php5-mysql</code></blockquote><h4 style="text-align: left;">    <span style="background-color: white;">Running PHP server (not Apache)</span></h4>To run the php server instead of Apache, just run following command in terminal.<br /><blockquote class="tr_bq"><code>php -S localhost:8080</code></blockquote>This will run a server listening at port 8080. So, we'll need to go to <a href="http://localhost:8080/">http://localhost:8080</a>&nbsp;to run the server. In order to run the server as simply <a href="http://localhost/">http://localhost</a>, we'll need to run the server at port 80, and for that we need to run the above command with sudo and 80 instead of 8080. Here's what I mean:<br /><blockquote class="tr_bq"><code>sudo php -S localhost:80</code></blockquote><h3 style="text-align: left;">    <span style="background-color: white;">Benefits of using PHP Server</span></h3><br /><ul style="text-align: left;"><li><span style="background-color: white;">PHP server run as the current working directory as the root server dir. So there is no need to go through the hassle of creating different sites in apache.</span></li><li><span style="background-color: white;">Running php server helps a lot in debugging by displaying all the messages, errors and warnings in the terminal itself. So no need to change php.ini to enable debugging or use some other method.&nbsp;</span></li><li><span style="background-color: white;">It is really cool to use it (don't know why, but I feel like it is cool :P)</span></li></ul><div>Here's a snapshot of how it look when running php server.<br /><br /><br /></div><div><span id="goog_2392878"></span><span id="goog_2392879"></span></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-_raAYxZsmQI/T_Ad5Kwo0CI/AAAAAAAAAQk/gUaZ2-1J7ho/s1600/snapshot1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="205" src="http://2.bp.blogspot.com/-_raAYxZsmQI/T_Ad5Kwo0CI/AAAAAAAAAQk/gUaZ2-1J7ho/s400/snapshot1.png" width="400" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"></div><br /></div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting up your own home LAMP machine for PHP development -Setting Apache]]></title>
    <link href="http://beatofthegeek.com/2012/06/setting-up-you-own-home-lamp-machine.html"/>
    <updated>2012-06-30T00:00:00+05:30</updated>
    <id>http://beatofthegeek.com/2012/06/setting-up-you-own-home-lamp-machine</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on"><div style="text-align: justify;">Hello there!!</div><div style="text-align: justify;">Well am back here after a long time. Writing blog posts is really boring when you have something as awesome as writing code, and writing code for web applications is what is red hot in the skies right now. So here's this post to help us setting up our own LAMP (Linux - which all of us already have, Apache - the HTTP server, MySql - the Database Management System, and PHP - the sexy thing we'll write our web apps in).&nbsp;</div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: right; margin-left: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><a href="http://www.ezeelive.com/cmsAdmin/uploads/php_web_developer_mumbai_india_ezeelive.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="225" src="http://www.ezeelive.com/cmsAdmin/uploads/php_web_developer_mumbai_india_ezeelive.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Php Development in Linux</td></tr></tbody></table><div style="text-align: justify;">Yea I know it is dead easy to just use the <a href="http://sourceforge.net/projects/lampas/" target="_blank">LAMP</a> (like people use <a href="http://www.wampserver.com/en/" target="_blank">WAMP</a> on <a href="http://forums.opensuse.org/english/other-forums/community-fun/general-chit-chat/461353-10-reasons-why-windows-still-sucks.html" target="_blank">Windows</a>), but what's the meaning of using something as awesome as Linux if we are gonna use those tools<span style="background-color: white;">(no offenses here)</span><span style="background-color: white;">. I hate using LAMP anyways.</span></div><div style="text-align: justify;"><span style="background-color: white;">So what we gonna do is installing Apache, Mysql and PHP on our machine and setting it up for awesome developing PHP apps.</span></div><!-- more --><br /><h3 style="text-align: justify;">   <span style="background-color: white;">Installing Apache</span></h3><div style="text-align: justify;"><span style="background-color: white;">Well, it can't be done easier on our Ubuntu Machine.</span></div><blockquote class="tr_bq" style="text-align: justify;"><span style="background-color: white;"><code>sudo apt-get install apache2</code></span></blockquote><div style="text-align: justify;">Installing apache is easy enough, but I don't think we gonna use our machine for web development all the time, are we? By default apache puts itself into the startup applications list, i.e. it starts up everytime we boot up. That's a kind of overkill for our development environment. But it is easy to remove it from startup.</div><h4 style="text-align: justify;">   Removing Apache from Startup</h4><div style="text-align: justify;">Just launch the terminal console (alt+ctrl+T on Gnome) and execute the following command</div><blockquote class="tr_bq" style="text-align: justify;"><code>sudo update-rc.d apache2 disable</code></blockquote><div style="text-align: justify;">Now Apache will not start on the startup. We'll need to start it manually everytime we gonna use it. Just use following command to <b>start apache http server:</b>&nbsp;</div><blockquote class="tr_bq" style="text-align: justify;"><code>sudo /etc/init.d/apache2 start</code> OR<span style="background-color: white;">&nbsp;</span></blockquote><blockquote class="tr_bq" style="text-align: justify;"><code>sudo service apache2 start</code></blockquote><h4 style="text-align: justify;">   Changing www (default directory) in Apache</h4><div style="text-align: justify;">By default Http server runs and show those files in <i>http:/localhost </i>which are located in the /var/www directory. But many times we need to change that directory to something else like ~/www or anything so as to run the server with that site as root.&nbsp;</div><div style="text-align: justify;">To achieve this in apache, we need to follow these steps:</div><br /><ul style="text-align: left;"><li style="text-align: justify;">Go to <i>/etc/apache2/sites-available</i> directory</li><li><div style="text-align: justify;"><span style="background-color: white;">Copy the file named </span><i style="background-color: white;">default </i><span style="background-color: white;">into the same (</span><i style="background-color: white;">/etc/apache2/sites-available</i><span style="background-color: white;">) directory and rename it to whatever (say 'www' this time) OR use this command via terminal</span></div><span style="background-color: white;"><div style="text-align: justify;"><span style="background-color: white;"><code>cp&nbsp;</code></span><code><i style="background-color: white;">/etc/apache2/sites-available/default&nbsp;</i><i style="background-color: white;">/etc/apache2/sites-available/www</i></code></div></span><i style="background-color: white;"><div style="text-align: justify;"><br /></div></i></li><li><div style="text-align: justify;"><span style="background-color: white;">Open up the 'www' file we created in text editor OR use this command via terminal</span></div><i style="background-color: white;"><div style="text-align: justify;"><i style="background-color: white;"><code>kate (or gedit) /etc/apache2/sites-available/www</code></i></div></i></li></ul><ul style="text-align: left;"><li style="text-align: justify;">Find and replace "/var/www" with the path we wanna use as our server root, say "/home/dante/www"</li></ul><div style="text-align: justify;">And that's all for the tough part. Now we have created a different site which we can enable or disable via command line anytime. This give us the power to use multiple server roots and switch between them easily.</div><div style="text-align: justify;">To enable our new site (i.e. to change the server root dir), enter following command in terminal</div><blockquote class="tr_bq" style="text-align: justify;"><code>sudo a2ensite www</code></blockquote><div style="text-align: justify;">But before that we need to disable already enabled default site, to disable it run</div><blockquote class="tr_bq" style="text-align: justify;"><code>sudo a2dissite default</code></blockquote><div style="text-align: justify;">Simple enough, huh!<br />Well I can't agree more that this is quite a hassle to just changing server root dirs. But here's an alternative.<br /><b>Alternatively, </b>we can create a virtualhost.<br />For this, we'll edit the default &nbsp;file in /etc/apache2sites-available/ and also the /etc/hosts file. Then we'll give different projects different URIs (that will be accessible only to your computer) and use those URIs instead of 127.0.0.1 or something. For example, for a project called 'php-project', we'll assign phpproject.dev (can be anything) and enter http://phpproject.dev in browser to see our project.<br />Here's how we do it.<br /><br /><b>CREATE VIRTUAL HOST:</b><br /><br /><ul><li>Change directory to /etc/apache2/sites-available<br /><span style="font-family: Courier New;"><i>cd /etc/apache2/sites-available</i></span></li><li><span style="font-family: Courier New;">Open 'default' in editor<br /><i>sudo gedit&nbsp;</i></span><span style="font-family: Courier New;">/etc/apache2/sites-available/default</span></li><li><span style="font-family: 'Courier New';">Enter following at the end of file&nbsp;</span><i><virtualhost><br /></virtualhost></i><i>&nbsp;&nbsp;</i>DocumentRoot "/home/[username]/phpProject/" <br />&nbsp; ServerName phpproject.dev <i>&nbsp; &nbsp;&nbsp;</i></li></ul></div><br /><br />Here, DocumentRoot is the location of your project ([username] is your username, like 'channi'), and phpproject.dev is the name you want to access the project with (its local browser address)<br /><br /><b>EDIT /etc/hosts</b><br /><div style="text-align: justify;"><ul><li>Open /etc/hosts in editor<br /><i>sudo gedit /etc/hosts</i></li><li>Enter following line at the end<br /><i>0.0.0.0 &nbsp;phpproject.dev</i><br /><br />(phpproject.dev can be anything like iamawesome.com or whatever, but keep it same as ServerName in /etc/apache2/sites-available/defautl file)</li></ul><div>And that's it. You can now simply open up your browser and go to phpproject.dev, and your project is there for you.</div><br /><br /></div><div style="text-align: justify;">Wish there was an easy way. If you are thinking the same, then congrats actually, php5.4 comes with an inbuilt server script which can solve many of our problems and provide a nice and easy way to debug php apps. We'll talk about it shortly. &nbsp;</div><div style="text-align: justify;">So let's <a href="http://channikhabra.blogspot.in/2012/07/setting-up-your-own-lamp-machine-for.html">setup Mysql and PHP</a>.</div><div style="text-align: justify;"><a href="http://channikhabra.blogspot.in/2012/07/setting-up-your-own-lamp-machine-for.html" target="">&gt;&gt;NEXT&gt;&gt;</a></div></div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Manually copy software(.deb files) from apt-get archives for future installs/backup]]></title>
    <link href="http://beatofthegeek.com/2011/07/manually-copy-softwaredeb-files-from.html"/>
    <updated>2011-07-08T00:00:00+05:30</updated>
    <id>http://beatofthegeek.com/2011/07/manually-copy-softwaredeb-files-from</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on"><div style="text-align: left;"><div><h1><span class="Apple-style-span" style="font-size: small; font-weight: normal;"><em>Only for Debian based distros; Ubuntu, Mint etc.</em></span></h1><h1><span class="Apple-style-span" style="font-size: small; font-weight: normal;">It is easy (and yes, possible as well) to copy software which are installed using apt-get\aptitude\synaptic etc. and save them for future install on other computer or just for backup. For this do the following:</span></h1><ul style="text-align: left;"><li>You need to be root to copy files from archives, so start a root session of nautilus<i>.</i>&nbsp;Open the terminal and type<br /><span class="Apple-style-span"><code></code></span><code><span class="Apple-style-span" style="color: #274e13;">sudo nautilus</span>&nbsp;</code><br />and then enter password when prompted.</li><li>A nautilus window will open up (don't panic. it is just your file manager). Navigate to /var/cache/apt/archives/<!-- more --></li><li>Here saved are all the files which are installed using apt-get or another package manager which use apt-get at back (aptitude, synaptic). Locate the software you are interested in (.deb files).</li><li>Copy .deb files on a USB or any other place and carry them to offline computer.</li><li><span class="Apple-style-span" style="color: #990000;">I highly recommend to <b>copy all the .deb files available in .../archives directory </b>even if you don't need them since every software depend on a lot of dependencies which are difficult to locate manually.</span></li><li>On the offline machine, again open the root session of nautilus (<code>sudo nautilus</code>).</li></ul></div><div style="text-align: left;"><span class="Apple-style-span" style="color: #6aa84f;"><span class="Apple-style-span" style="font-size: large;">Installing on Offline Machine&nbsp;</span><span class="Apple-style-span" style="font-size: large;">»</span></span><br /><span class="Apple-style-span" style="color: #660000; font-size: large;">Can be done this way</span><span class="Apple-style-span" style="font-size: large;"> <span class="Apple-style-span" style="color: red;">»</span></span></div><ul style="text-align: left;"><li>Copy and paste all the .deb files from USB stick (or whatever media you used) to /var/cache/apt/archives/ directory (you need to use 'sudo nautilus' for this).</li><li>When everything is done, close nautilus.</li><li>In the Terminal window (ctrl+T), type<br /><code>sudo apt-get install "your package name"</code></li><li>Apt-get look for a package in archives first and try to download it only if it is not present there. So in any case, this method must work perfectly.</li></ul><a href="http://www.blogger.com/post-edit.g?blogID=3664370465667971076&amp;postID=3082173511827674230" name="Synaptic"></a><br /><span class="Apple-style-span" style="color: #274e13; font-size: large;">Recommended way:</span><span class="Apple-style-span" style="color: #6aa84f; font-size: large;"> »</span></div><div style="text-align: left;"><ul style="text-align: left;"><li>Copy all files from USB stick to hard drive (not necessary).</li><li>Open <b>Synaptic package manager</b> (inbuilt in Ubuntu).</li><li>Select "Add Downloaded software" from File menu.</li><li>Navigate to location where you copied your software (or USB/CD containing it).</li><li>Synaptic will install them without any problem</li></ul></div><div style="text-align: left;"><ul style="text-align: left;"></ul><span class="Apple-style-span" style="color: #990000;">Precautions:</span></div><div style="text-align: left;"><ul style="text-align: left;"><a href="http://4.bp.blogspot.com/-om7W-momaps/ThMWBcYhlBI/AAAAAAAAAB8/HhnTQlIQ3cI/s1600/Screenshot.png" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" height="257" src="http://4.bp.blogspot.com/-om7W-momaps/ThMWBcYhlBI/AAAAAAAAAB8/HhnTQlIQ3cI/s320/Screenshot.png" width="320" /></a><li>Take care that the architectures of both the computers involved in this process are same i.e. both run either 32 bit or 64 bit versions of the OS.</li><li>When running nautilus with root privileges, take care that you don't delete or change anything just because your genius mind think it is useless.</li><li>It is&nbsp;recommended&nbsp;that both the computer run same version of OS, it is not necessary though.</li></ul>Although it is possible to transfer software with this method, but it involves a lot of manual work. If you are a lazy junk (like me :P ), software like Aptoncd are available to automate this process and they do it very well.<br /><br /><hr \="" style="text-align: justify;" /><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><b><i>Circle Beat Of The Geek on</i></b>&nbsp;<a href="https://plus.google.com/109838896781876000861" target="_blank">Google Plus</a></div><div style="text-align: justify;"><i><b>OR Like us on</b></i>&nbsp;<a href="https://www.facebook.com/pages/Beat-Of-The-Geek/251813454834549" target="_blank">Facebook</a>&nbsp;<b><i>&nbsp;OR Follow on</i></b>&nbsp;<a href="https://twitter.com/#!/beatofthegeek" target="_blank">Twitter</a></div></div></div></div>

]]></content>
  </entry>
  
</feed>
