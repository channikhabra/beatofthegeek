<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: git | Beat of The Geek]]></title>
  <link href="http://\.github.io/\/github/blog/categories/git/atom.xml" rel="self"/>
  <link href="http://\.github.io/\/github/"/>
  <updated>2015-11-04T08:05:54+05:30</updated>
  <id>http://\.github.io/\/github/</id>
  <author>
    <name><![CDATA[Charanjit Singh]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Differnet ways of accessing a commit in git]]></title>
    <link href="http://\.github.io/\/github/2014/02/differnet-ways-of-accessing-commit-in.html"/>
    <updated>2014-02-02T00:00:00+05:30</updated>
    <id>http://\.github.io/\/github/2014/02/differnet-ways-of-accessing-commit-in</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on">Ok, so it's been quite long since I wrote anything for this blog. I made a resolution earlier about 'a post a day' which is apparently shattered. So here's a quick and dirty posts straight from my notes to help bringing me back on track. Any help it does to anyone else is a bonus :)<br /><br />So as we discussed in a previous post, there are many names for a commit (noun) in git. We may call it a branch, a tag, or just a commit, they are just different ways of accessing a commit.<br /><br />So, here's an incomplete list of different ways in which we can access a commit in git. <br /><br /><!-- more --><br /><br /><h4 style="text-align: left;">branch name</h4><div style="text-align: left;">A branch in git is nothing but a named commit. So whenever we are referring to a branch, we are basically just accessing a commit. </div><h4 style="text-align: left;">tag name</h4>Same is true for tags as branches in git. The only difference between a tag and a branch is that tags can have their own descriptions. <br /><h4 style="text-align: left;">HEAD</h4>HEAD represents currently checked-out commit. It's basically just a pointer to a commit.<br /><h4 style="text-align: left;">c23a23c43 </h4>A commit can of course be accessed with its full or abbreviated hash id. Abbreviated hash id is the hash id of the commit with minimum number of characters that are required to uniquely identify the commit. These are generally 7-8.<br /><blockquote class="tr_bq">from here on I am using word 'name' for any of the above mentioned ways of accessing a commit.</blockquote><h4 style="text-align: left;">name^&nbsp; and also name^^ </h4>Represents the parent of a commit. If multiple parents present, represent the first parent. More '^' means higher up the chain.<br /><h4>name^2</h4>It represents second parent of the commit if multiple parents are present<br /><h4 style="text-align: left;">name~5</h4>Same as name^^^^^<br /><h4 style="text-align: left;">name:path</h4>References a certain file within a commit's content tree<br /><h4 style="text-align: left;">name^{tree}</h4>Reference just the tree held by the commit, rather than the commit itself<br /><h4 style="text-align: left;">name1..name2</h4>A commit range. Refers to all commits reachable from name2 to name1. If either name1 or name2 is omitted, HEAD is used in its place.<br /><h4 style="text-align: left;">name1...name2</h4>For git log, it refers to all commits referenced by name1 or name2, but not by both.<br />For git diff, the range expressed is between name2 and the common ancestor of name1 and name2.<br /><h4 style="text-align: left;">--since="2 weeks ago"</h4>Refers to all commits since a certain date<br /><h4 style="text-align: left;">--until="1 week ago"</h4>Refers to all commits up to a certain date<br /><h4 style="text-align: left;">--grep=pattern</h4>Refers to all commits whose commit message matches the regular expression<br /><h4 style="text-align: left;">--committer=pattern</h4>Refers to all commits whose committer matches the pattern<br /><h4 style="text-align: left;">--no-merges</h4>Refers to all commits in the range that have only one parent</div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git commit illustrated: Simplicity revealed by a complex exercise for simplest git task]]></title>
    <link href="http://\.github.io/\/github/2014/01/git-commit-illustrated-simplicity.html"/>
    <updated>2014-01-10T00:00:00+05:30</updated>
    <id>http://\.github.io/\/github/2014/01/git-commit-illustrated-simplicity</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on"><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-2hJwSV2bj7I/Us-k_1d6bnI/AAAAAAAAAlQ/FplZr00hLCk/s1600/46.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-2hJwSV2bj7I/Us-k_1d6bnI/AAAAAAAAAlQ/FplZr00hLCk/s1600/46.png" height="236" width="400" /></a></div>In this post I will try to explain the underlying commands and to a level the internal working of the git system involved when making a 'commit'.<br />This post is actually the by-product of my research for another post about git (.git/ actually).  I was so much astonished by the amount of myths about complexity of git system removed from my mind, that I decided to make it the today's post itself. To me the git system appears much simple now than yesterday.<br /><h3 style="text-align: left;">Commit </h3>Commit is the central piece of the git system. The git world is simply a collection of commit objects, each of which hold a tree, which hold references to other trees and blobs. The branches, the tags, the HEAD are just fancy aliases for commits (more on these in some other post (next may be)).<br />A commit is basically the snapshot of present working tree. I will spare the details  for a future post (it's worth it).<br /><br />Let's now discuss what this post is about. Revealing the secrets involved in every git users ritual of 'commit'ing, and performing a commit manually.<br /><br /><!-- more -->This should reveal quite some details about the internal working of git (no you don't need to run away, it's not that deep).<br /><br />You might already know the concepts, but knowing sex and having sex are kind of different things.<br /><br />Ok! Let's start the <b>exercise for manual commit</b>.<br /><br />First we need to create an empty directory, call it 'work'. And some simple file in it.<br /><blockquote class="tr_bq">=&gt; mkdir work<br />=&gt; echo "Hello world!" &gt; hello_world</blockquote>Initiate a git repo in it and add the 'hello_world' file<br /><blockquote class="tr_bq">=&gt; git init</blockquote>We will keep an eye on the changes that happen in the '.git' repo throughout our exercise. For now check out what's saved in the HEAD.<br /><blockquote class="tr_bq">=&gt; cat .git/HEAD<br />=&gt; ref: refs/heads/master</blockquote>As HEAD is basically just a reference to the commit which represents the current commit associated with the working tree. So one might guess .git/refs/heads/master would point to the tip of a branch. Let's check it <br /><blockquote class="tr_bq">=&gt; ls .git/refs/heads/master<br />=&gt; <br />=&gt; git branch<br />=&gt;</blockquote>There is nothing in there. Since we have not committed any commits yet, there are no branches (since branches are merely named commits which happen to have multiple child commits).<br />If you are feeling adventurous, you can try 'git log'.<br /><blockquote class="tr_bq">=&gt; git log<br />=&gt; fatal: bad default revision 'HEAD'</blockquote>Let's now <b>add our file to the staging area</b><br /><blockquote class="tr_bq">=&gt; git add hello_world</blockquote><blockquote class="tr_bq"><b>Staging area is the middle system which keeps our content after 'git add' and before 'git commit'</b></blockquote><blockquote class="tr_bq">&nbsp;<b>A blob is the git's representation of a file. It's not actually a file, but just the content. A blob do not have any name or other metadata. It's referenced in trees which contain metadata for blobs.<br />Tree is the object which stores references to other trees and blobs as leaf nodes.</b></blockquote>This command converted content of 'hello_world' file into a blob and placed it in the index (aka staging area). A 'blob' is how our content is represented in git. You can check the .git dir, a new file 'index' is created. This file contain the references to all blobs and trees which get added to our staging area.<br /><blockquote class="tr_bq">=&gt; ls .git<br />=&gt; branches&nbsp; config&nbsp; description&nbsp; HEAD&nbsp; hooks *index*&nbsp; info&nbsp; objects&nbsp; refs</blockquote>At this point we would generally just 'commit' the 'index', but not this time. The 'git commit' command hides many details and is a great convenience. You'll value it after this exercise.<br /><br />Git store all our content in form of blobs. The blobs do not have any kind of meta-data attached with them (like name, creation date or something). They are just nameless 'blobs'. To identify a blob, they are saved in 'trees' as leaf nodes. Different trees can save reference to same blob with different meta-data attached. But a git repository will have exactly one copy of a blob. This is the reason of compact storage of git.<br /><br />We can see the blob for our content in 'hello world' present in staging area (index)<br /><blockquote class="tr_bq">=&gt; git ls-files --stage<br />=&gt; 100644 802992c4220de19a90767f3000a79a31b98d0df7 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hello_world</blockquote>If you entered the same content as me, both your and my hashes should be same. We can check what type of object the above hash belong to<br /><blockquote class="tr_bq">=&gt; git cat-file -t 802992c<br />=&gt; blob</blockquote>The above blob is not referenced by any tree. It's only referenced from .git/index (which store references to objects (blobs and trees) which make up our staging area).<br />&nbsp;A 'commit' object in git holds a single tree. A tree may have references to more trees or blobs. So to 'commit' the above created blob of our content, we need a tree. <br /><br />So we now need to create a tree. <br /><blockquote class="tr_bq">=&gt; git write-tree<br />=&gt; cdbf8e1f00e97366e01cbf2d73f3689a60107686</blockquote>'write-tree' command make a tree with the contents of the 'index'.<br />Now when we have the tree, let's create a commit object with it.<br /><blockquote class="tr_bq">=&gt; echo "Initial commit" | git commit-tree cdbf8e1<br />=&gt; a5a86835ba72e3ca7d5267c68c06c212392f9b7d</blockquote>That's the hash for our commit object. You directly use 'git commit <tree-hash>'. Then the command will wait for the commit message to be entered and 'ctrl-d' for proceeding.</tree-hash><br /><br />So our commit object is ready, and we are done. Right? Not actually. What we have created is called an 'unreachable commit'. <br /><b>An unreachable commit</b> is a commit which do not have any parents and which is not referenced by any of the files in .git/refs/heads/. Such commits are automatically removed by the git system after some time.<br />&nbsp;To make our commit reachable, we need to create a reference in a file in .git/refs/heads. <br /><blockquote class="tr_bq">=&gt; echo a5a86835ba72e3ca7d5267c68c06c212392f9b7d &gt; .git/refs/heads/hello</blockquote>Actually we should instead use the more safe way to update references in git system.<br /><blockquote class="tr_bq">=&gt; git update-refs refs/head/hello a5a86835ba72e3ca7d5267c68c06c212392f9b7d</blockquote>Here if we had used name 'master' instead of 'hello', we could have used 'git log'. But now it's still giving 'fatal:' because the HEAD is referring to 'refs/heads/master' which does not exist.<br /><br />Now try the command 'git branch'.<br /><blockquote class="tr_bq">=&gt; git branch <br />=&gt; hello</blockquote>Here we see what a branch actually is to git. A reference to a 'commit' object.<br />Wait there is more to it. Now when we have created the branch 'hello', we need to make HEAD refer to it. <br /><blockquote class="tr_bq">=&gt; git symbolic-ref HEAD refs/heads/hello</blockquote>This command associated our working tree with the newly created branch/commit of ours. This is what actually happens on a checkout normally.<br />Now we can use 'git log'. If you are using 'zsh' with appropriate theme, at this point the git branch indicator will change form uncommitted 'master' to committed 'hello'.<br /><br />Now we are done. Officially. Git system is this frighteningly simple inside. Hope this was as helpful for you as it was for me. I really enjoyed writing this post.</div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5 things I frequently do and forget with git]]></title>
    <link href="http://\.github.io/\/github/2014/01/5-things-i-frequently-do-and-forget.html"/>
    <updated>2014-01-08T00:00:00+05:30</updated>
    <id>http://\.github.io/\/github/2014/01/5-things-i-frequently-do-and-forget</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on">Here are few things I used to do a lot in my starting days with git and then forgot to re-search them when needed next time. These tips are from my notes. <br /><br /><h3 style="text-align: left;">How to undo the last Git commit?</h3>There are two scenarios in this case, and hence two ways to achieve our goal.<br /><h4 style="text-align: left;">Hard Reset - Completely undo the last commit and all the changes it made.</h4><blockquote class="tr_bq">git reset --hard HEAD~1</blockquote>Imagine the state of the tree is as following:<br /><br /><blockquote>&nbsp;&nbsp; (F)<br />A-B-C<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ↑<br />&nbsp; master</blockquote><br /><!-- more --><br /><br />where (F) is the current state of files and 'C' is the commit we want to undo. The above command completely removes the last commit along with all the changes involved in the commit. The new state of the tree is like this:<br /><br /><blockquote class="tr_bq">&nbsp;(F)<br />A-B<br />&nbsp;&nbsp;&nbsp; ↑<br />master</blockquote><br /><br /><blockquote class="tr_bq"><b>What is HEAD?</b><br />We can think of the HEAD as the "current branch". HEAD is basically a pointer which points to the latest commit. When we switch branches with git checkout, the HEAD revision changes to point to the tip of the new branch.</blockquote><blockquote class="tr_bq"><b>What is HEAD~1?</b><br />It's kind of complicated to explain HEAD~1 without explaining HEAD^1.<br />HEAD^1&nbsp; means the first parent of the commit object. ^<n> means the <n>th parent.<br />HEAD~1 means the commit object that is the first generation grand-parent of the named commit object, following only the first parents. e.g <rev>~3 is equivalent to <rev>^^^ which is equivalent to <rev>^1^1^1.</rev></rev></rev></n></n></blockquote><h4 style="text-align: left;">Undo the commit but keep the changes</h4><blockquote class="tr_bq">git reset HEAD~1</blockquote>If we want to undo the last commit for some reason (like if we entered the wrong commit message or the commit was incomplete), we can use a soft reset on HEAD.<br />In this case, the tree structure changes to something like:<br /><br /><blockquote>&nbsp;&nbsp; (F)<br />A-B-C<br />&nbsp;&nbsp; ↑<br />master</blockquote><br /><b>What's happening?</b><br />In both cases, HEAD is just a pointer to the latest commit. When we do a git reset HEAD~1, we tell Git to move the HEAD pointer back one commit. But (unless we use --hard) we leave your files as they were. So now git status shows the changes you had checked into C. You haven't lost a thing!<br /><h3 style="text-align: left;">How to change the commit message of last commit</h3><blockquote class="tr_bq">git reset --soft HEAD~1</blockquote>Using this command we undo the last commit but keep the files as well as the index untouched. This means we can just recommit with no extra effort as a new commit with a new commit message.<br /><br /><b>What's happening here?</b><br />Same as first point. But it leaves the files as well as the index unchanged, so we just need to 'commit' again with a new commit message.<br /><h3 style="text-align: left;">How to get a commit back after 'reset --hard'</h3>In the first point, we undid the previous commit permanently(?). Sometimes (read often) it happens that we need the destroyed commit back. Following commands can be used to resurrect the destroyed commit.<br /><blockquote class="tr_bq">git reflog </blockquote>This command shows a list of partial commit shas. We need to choose the commit we want to restore from this list and use following command.<br /><blockquote class="tr_bq">git checkout -b someNewBranchName shaOfDestroyedCommit</blockquote>This will create a new branch and restore the destroyed commit in it, which we can re-merge as required.<br /><br /><b>What's happening here?</b><br />Commits don't actually get destroyed in git for about 90 days. So usually we can go back and restore commits with method explained above.<br /><h3 style="text-align: left;">How to remove a git submodule?</h3><blockquote class="tr_bq">Git submodule?</blockquote>Submodules allow foreign repositories to be embedded within a dedicated subdirectory of the source tree, always pointed at a particular commit. Submodules are meant for different projects you would like to make part of your source tree, while the history of the two projects still stays completely independent and you cannot modify the contents of the submodule from within the main project.<br /><h4 style="text-align: left;">Removing a git submodule</h4>Git submodules can simply be removed with 'git rm', but that keeps the submodule entry intact in the .git/config and .gitmodules. There is actually an easier way to remove submodules with a single command.<br /><blockquote class="tr_bq">git submodule deinit <submodule name=""><br /></submodule></blockquote>This is in comprehension to 'git submodule init' command and does all the submodule removal work itself.<br /><h3 style="text-align: left;">How to delete a remote git branch?</h3>&nbsp;This one is easy. We just need one command to delete a remote branch.<br /><blockquote class="tr_bq">git push origin --delete <branchname><br /></branchname></blockquote>To remove a local branch, we can of course use<br /><blockquote class="tr_bq">git branch -d <localbranch><br /></localbranch></blockquote><br /></div></div>

]]></content>
  </entry>
  
</feed>
